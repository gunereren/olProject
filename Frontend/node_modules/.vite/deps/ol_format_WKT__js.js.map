{
  "version": 3,
  "sources": ["../../ol/format/TextFeature.js", "../../ol/format/WKT.js"],
  "sourcesContent": ["/**\r\n * @module ol/format/TextFeature\r\n */\r\nimport FeatureFormat from '../format/Feature.js';\r\nimport {abstract} from '../util.js';\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * Base class for text feature formats.\r\n *\r\n * @abstract\r\n */\r\nclass TextFeature extends FeatureFormat {\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"./Feature.js\").Type} Format.\r\n   */\r\n  getType() {\r\n    return 'text';\r\n  }\r\n\r\n  /**\r\n   * Read the feature from the source.\r\n   *\r\n   * @param {Document|Element|Object|string} source Source.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\r\n   * @return {import(\"../Feature.js\").default} Feature.\r\n   * @api\r\n   */\r\n  readFeature(source, options) {\r\n    return this.readFeatureFromText(\r\n      getText(source),\r\n      this.adaptOptions(options)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {string} text Text.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\r\n   * @protected\r\n   * @return {import(\"../Feature.js\").default} Feature.\r\n   */\r\n  readFeatureFromText(text, options) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Read the features from the source.\r\n   *\r\n   * @param {Document|Element|Object|string} source Source.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\r\n   * @return {Array<import(\"../Feature.js\").default>} Features.\r\n   * @api\r\n   */\r\n  readFeatures(source, options) {\r\n    return this.readFeaturesFromText(\r\n      getText(source),\r\n      this.adaptOptions(options)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {string} text Text.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\r\n   * @protected\r\n   * @return {Array<import(\"../Feature.js\").default>} Features.\r\n   */\r\n  readFeaturesFromText(text, options) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Read the geometry from the source.\r\n   *\r\n   * @param {Document|Element|Object|string} source Source.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\r\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\r\n   * @api\r\n   */\r\n  readGeometry(source, options) {\r\n    return this.readGeometryFromText(\r\n      getText(source),\r\n      this.adaptOptions(options)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {string} text Text.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\r\n   * @protected\r\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\r\n   */\r\n  readGeometryFromText(text, options) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Read the projection from the source.\r\n   *\r\n   * @param {Document|Element|Object|string} source Source.\r\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\r\n   * @api\r\n   */\r\n  readProjection(source) {\r\n    return this.readProjectionFromText(getText(source));\r\n  }\r\n\r\n  /**\r\n   * @param {string} text Text.\r\n   * @protected\r\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\r\n   */\r\n  readProjectionFromText(text) {\r\n    return this.dataProjection;\r\n  }\r\n\r\n  /**\r\n   * Encode a feature as a string.\r\n   *\r\n   * @param {import(\"../Feature.js\").default} feature Feature.\r\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\r\n   * @return {string} Encoded feature.\r\n   * @api\r\n   */\r\n  writeFeature(feature, options) {\r\n    return this.writeFeatureText(feature, this.adaptOptions(options));\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {import(\"../Feature.js\").default} feature Features.\r\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\r\n   * @protected\r\n   * @return {string} Text.\r\n   */\r\n  writeFeatureText(feature, options) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Encode an array of features as string.\r\n   *\r\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\r\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\r\n   * @return {string} Encoded features.\r\n   * @api\r\n   */\r\n  writeFeatures(features, options) {\r\n    return this.writeFeaturesText(features, this.adaptOptions(options));\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\r\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\r\n   * @protected\r\n   * @return {string} Text.\r\n   */\r\n  writeFeaturesText(features, options) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Write a single geometry.\r\n   *\r\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\r\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\r\n   * @return {string} Geometry.\r\n   * @api\r\n   */\r\n  writeGeometry(geometry, options) {\r\n    return this.writeGeometryText(geometry, this.adaptOptions(options));\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\r\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\r\n   * @protected\r\n   * @return {string} Text.\r\n   */\r\n  writeGeometryText(geometry, options) {\r\n    return abstract();\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Document|Element|Object|string} source Source.\r\n * @return {string} Text.\r\n */\r\nfunction getText(source) {\r\n  if (typeof source === 'string') {\r\n    return source;\r\n  }\r\n  return '';\r\n}\r\n\r\nexport default TextFeature;\r\n", "/**\r\n * @module ol/format/WKT\r\n */\r\nimport Feature from '../Feature.js';\r\nimport GeometryCollection from '../geom/GeometryCollection.js';\r\nimport LineString from '../geom/LineString.js';\r\nimport MultiLineString from '../geom/MultiLineString.js';\r\nimport MultiPoint from '../geom/MultiPoint.js';\r\nimport MultiPolygon from '../geom/MultiPolygon.js';\r\nimport Point from '../geom/Point.js';\r\nimport Polygon from '../geom/Polygon.js';\r\nimport TextFeature from './TextFeature.js';\r\nimport {transformGeometryWithOptions} from './Feature.js';\r\n\r\n/**\r\n * Geometry constructors\r\n * @enum {function (new:import(\"../geom/Geometry.js\").default, Array, import(\"../geom/Geometry.js\").GeometryLayout)}\r\n */\r\nconst GeometryConstructor = {\r\n  'POINT': Point,\r\n  'LINESTRING': LineString,\r\n  'POLYGON': Polygon,\r\n  'MULTIPOINT': MultiPoint,\r\n  'MULTILINESTRING': MultiLineString,\r\n  'MULTIPOLYGON': MultiPolygon,\r\n};\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into\r\n * multiple features on reading.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Token\r\n * @property {number} type Type.\r\n * @property {number|string} [value] Value.\r\n * @property {number} position Position.\r\n */\r\n\r\n/**\r\n * @const\r\n * @type {string}\r\n */\r\nconst EMPTY = 'EMPTY';\r\n\r\n/**\r\n * @const\r\n * @type {string}\r\n */\r\nconst Z = 'Z';\r\n\r\n/**\r\n * @const\r\n * @type {string}\r\n */\r\nconst M = 'M';\r\n\r\n/**\r\n * @const\r\n * @type {string}\r\n */\r\nconst ZM = 'ZM';\r\n\r\n/**\r\n * @const\r\n * @enum {number}\r\n */\r\nconst TokenType = {\r\n  START: 0,\r\n  TEXT: 1,\r\n  LEFT_PAREN: 2,\r\n  RIGHT_PAREN: 3,\r\n  NUMBER: 4,\r\n  COMMA: 5,\r\n  EOF: 6,\r\n};\r\n\r\n/**\r\n * @type {Object<import(\"../geom/Geometry.js\").Type, string>}\r\n */\r\nconst wktTypeLookup = {\r\n  Point: 'POINT',\r\n  LineString: 'LINESTRING',\r\n  Polygon: 'POLYGON',\r\n  MultiPoint: 'MULTIPOINT',\r\n  MultiLineString: 'MULTILINESTRING',\r\n  MultiPolygon: 'MULTIPOLYGON',\r\n  GeometryCollection: 'GEOMETRYCOLLECTION',\r\n  Circle: 'CIRCLE',\r\n};\r\n\r\n/**\r\n * Class to tokenize a WKT string.\r\n */\r\nclass Lexer {\r\n  /**\r\n   * @param {string} wkt WKT string.\r\n   */\r\n  constructor(wkt) {\r\n    /**\r\n     * @type {string}\r\n     */\r\n    this.wkt = wkt;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.index_ = -1;\r\n  }\r\n\r\n  /**\r\n   * @param {string} c Character.\r\n   * @return {boolean} Whether the character is alphabetic.\r\n   * @private\r\n   */\r\n  isAlpha_(c) {\r\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\r\n  }\r\n\r\n  /**\r\n   * @param {string} c Character.\r\n   * @param {boolean} [decimal] Whether the string number\r\n   *     contains a dot, i.e. is a decimal number.\r\n   * @return {boolean} Whether the character is numeric.\r\n   * @private\r\n   */\r\n  isNumeric_(c, decimal) {\r\n    decimal = decimal !== undefined ? decimal : false;\r\n    return (c >= '0' && c <= '9') || (c == '.' && !decimal);\r\n  }\r\n\r\n  /**\r\n   * @param {string} c Character.\r\n   * @return {boolean} Whether the character is whitespace.\r\n   * @private\r\n   */\r\n  isWhiteSpace_(c) {\r\n    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\r\n  }\r\n\r\n  /**\r\n   * @return {string} Next string character.\r\n   * @private\r\n   */\r\n  nextChar_() {\r\n    return this.wkt.charAt(++this.index_);\r\n  }\r\n\r\n  /**\r\n   * Fetch and return the next token.\r\n   * @return {Token} Next string token.\r\n   */\r\n  nextToken() {\r\n    const c = this.nextChar_();\r\n    const position = this.index_;\r\n    /** @type {number|string} */\r\n    let value = c;\r\n    let type;\r\n\r\n    if (c == '(') {\r\n      type = TokenType.LEFT_PAREN;\r\n    } else if (c == ',') {\r\n      type = TokenType.COMMA;\r\n    } else if (c == ')') {\r\n      type = TokenType.RIGHT_PAREN;\r\n    } else if (this.isNumeric_(c) || c == '-') {\r\n      type = TokenType.NUMBER;\r\n      value = this.readNumber_();\r\n    } else if (this.isAlpha_(c)) {\r\n      type = TokenType.TEXT;\r\n      value = this.readText_();\r\n    } else if (this.isWhiteSpace_(c)) {\r\n      return this.nextToken();\r\n    } else if (c === '') {\r\n      type = TokenType.EOF;\r\n    } else {\r\n      throw new Error('Unexpected character: ' + c);\r\n    }\r\n\r\n    return {position: position, value: value, type: type};\r\n  }\r\n\r\n  /**\r\n   * @return {number} Numeric token value.\r\n   * @private\r\n   */\r\n  readNumber_() {\r\n    let c;\r\n    const index = this.index_;\r\n    let decimal = false;\r\n    let scientificNotation = false;\r\n    do {\r\n      if (c == '.') {\r\n        decimal = true;\r\n      } else if (c == 'e' || c == 'E') {\r\n        scientificNotation = true;\r\n      }\r\n      c = this.nextChar_();\r\n    } while (\r\n      this.isNumeric_(c, decimal) ||\r\n      // if we haven't detected a scientific number before, 'e' or 'E'\r\n      // hint that we should continue to read\r\n      (!scientificNotation && (c == 'e' || c == 'E')) ||\r\n      // once we know that we have a scientific number, both '-' and '+'\r\n      // are allowed\r\n      (scientificNotation && (c == '-' || c == '+'))\r\n    );\r\n    return parseFloat(this.wkt.substring(index, this.index_--));\r\n  }\r\n\r\n  /**\r\n   * @return {string} String token value.\r\n   * @private\r\n   */\r\n  readText_() {\r\n    let c;\r\n    const index = this.index_;\r\n    do {\r\n      c = this.nextChar_();\r\n    } while (this.isAlpha_(c));\r\n    return this.wkt.substring(index, this.index_--).toUpperCase();\r\n  }\r\n}\r\n\r\n/**\r\n * Class to parse the tokens from the WKT string.\r\n */\r\nclass Parser {\r\n  /**\r\n   * @param {Lexer} lexer The lexer.\r\n   */\r\n  constructor(lexer) {\r\n    /**\r\n     * @type {Lexer}\r\n     * @private\r\n     */\r\n    this.lexer_ = lexer;\r\n\r\n    /**\r\n     * @type {Token}\r\n     * @private\r\n     */\r\n    this.token_ = {\r\n      position: 0,\r\n      type: TokenType.START,\r\n    };\r\n\r\n    /**\r\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\r\n     * @private\r\n     */\r\n    this.layout_ = 'XY';\r\n  }\r\n\r\n  /**\r\n   * Fetch the next token form the lexer and replace the active token.\r\n   * @private\r\n   */\r\n  consume_() {\r\n    this.token_ = this.lexer_.nextToken();\r\n  }\r\n\r\n  /**\r\n   * Tests if the given type matches the type of the current token.\r\n   * @param {TokenType} type Token type.\r\n   * @return {boolean} Whether the token matches the given type.\r\n   */\r\n  isTokenType(type) {\r\n    return this.token_.type == type;\r\n  }\r\n\r\n  /**\r\n   * If the given type matches the current token, consume it.\r\n   * @param {TokenType} type Token type.\r\n   * @return {boolean} Whether the token matches the given type.\r\n   */\r\n  match(type) {\r\n    const isMatch = this.isTokenType(type);\r\n    if (isMatch) {\r\n      this.consume_();\r\n    }\r\n    return isMatch;\r\n  }\r\n\r\n  /**\r\n   * Try to parse the tokens provided by the lexer.\r\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\r\n   */\r\n  parse() {\r\n    this.consume_();\r\n    return this.parseGeometry_();\r\n  }\r\n\r\n  /**\r\n   * Try to parse the dimensional info.\r\n   * @return {import(\"../geom/Geometry.js\").GeometryLayout} The layout.\r\n   * @private\r\n   */\r\n  parseGeometryLayout_() {\r\n    /** @type {import(\"../geom/Geometry.js\").GeometryLayout} */\r\n    let layout = 'XY';\r\n    const dimToken = this.token_;\r\n    if (this.isTokenType(TokenType.TEXT)) {\r\n      const dimInfo = dimToken.value;\r\n      if (dimInfo === Z) {\r\n        layout = 'XYZ';\r\n      } else if (dimInfo === M) {\r\n        layout = 'XYM';\r\n      } else if (dimInfo === ZM) {\r\n        layout = 'XYZM';\r\n      }\r\n      if (layout !== 'XY') {\r\n        this.consume_();\r\n      }\r\n    }\r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<import(\"../geom/Geometry.js\").default>} A collection of geometries.\r\n   * @private\r\n   */\r\n  parseGeometryCollectionText_() {\r\n    if (this.match(TokenType.LEFT_PAREN)) {\r\n      const geometries = [];\r\n      do {\r\n        geometries.push(this.parseGeometry_());\r\n      } while (this.match(TokenType.COMMA));\r\n      if (this.match(TokenType.RIGHT_PAREN)) {\r\n        return geometries;\r\n      }\r\n    }\r\n    throw new Error(this.formatErrorMessage_());\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} All values in a point.\r\n   * @private\r\n   */\r\n  parsePointText_() {\r\n    if (this.match(TokenType.LEFT_PAREN)) {\r\n      const coordinates = this.parsePoint_();\r\n      if (this.match(TokenType.RIGHT_PAREN)) {\r\n        return coordinates;\r\n      }\r\n    }\r\n    throw new Error(this.formatErrorMessage_());\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Array<number>>} All points in a linestring.\r\n   * @private\r\n   */\r\n  parseLineStringText_() {\r\n    if (this.match(TokenType.LEFT_PAREN)) {\r\n      const coordinates = this.parsePointList_();\r\n      if (this.match(TokenType.RIGHT_PAREN)) {\r\n        return coordinates;\r\n      }\r\n    }\r\n    throw new Error(this.formatErrorMessage_());\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Array<Array<number>>>} All points in a polygon.\r\n   * @private\r\n   */\r\n  parsePolygonText_() {\r\n    if (this.match(TokenType.LEFT_PAREN)) {\r\n      const coordinates = this.parseLineStringTextList_();\r\n      if (this.match(TokenType.RIGHT_PAREN)) {\r\n        return coordinates;\r\n      }\r\n    }\r\n    throw new Error(this.formatErrorMessage_());\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Array<number>>} All points in a multipoint.\r\n   * @private\r\n   */\r\n  parseMultiPointText_() {\r\n    if (this.match(TokenType.LEFT_PAREN)) {\r\n      let coordinates;\r\n      if (this.token_.type == TokenType.LEFT_PAREN) {\r\n        coordinates = this.parsePointTextList_();\r\n      } else {\r\n        coordinates = this.parsePointList_();\r\n      }\r\n      if (this.match(TokenType.RIGHT_PAREN)) {\r\n        return coordinates;\r\n      }\r\n    }\r\n    throw new Error(this.formatErrorMessage_());\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Array<Array<number>>>} All linestring points\r\n   *                                          in a multilinestring.\r\n   * @private\r\n   */\r\n  parseMultiLineStringText_() {\r\n    if (this.match(TokenType.LEFT_PAREN)) {\r\n      const coordinates = this.parseLineStringTextList_();\r\n      if (this.match(TokenType.RIGHT_PAREN)) {\r\n        return coordinates;\r\n      }\r\n    }\r\n    throw new Error(this.formatErrorMessage_());\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Array<Array<Array<number>>>>} All polygon points in a multipolygon.\r\n   * @private\r\n   */\r\n  parseMultiPolygonText_() {\r\n    if (this.match(TokenType.LEFT_PAREN)) {\r\n      const coordinates = this.parsePolygonTextList_();\r\n      if (this.match(TokenType.RIGHT_PAREN)) {\r\n        return coordinates;\r\n      }\r\n    }\r\n    throw new Error(this.formatErrorMessage_());\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} A point.\r\n   * @private\r\n   */\r\n  parsePoint_() {\r\n    const coordinates = [];\r\n    const dimensions = this.layout_.length;\r\n    for (let i = 0; i < dimensions; ++i) {\r\n      const token = this.token_;\r\n      if (this.match(TokenType.NUMBER)) {\r\n        coordinates.push(/** @type {number} */ (token.value));\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    if (coordinates.length == dimensions) {\r\n      return coordinates;\r\n    }\r\n    throw new Error(this.formatErrorMessage_());\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Array<number>>} An array of points.\r\n   * @private\r\n   */\r\n  parsePointList_() {\r\n    const coordinates = [this.parsePoint_()];\r\n    while (this.match(TokenType.COMMA)) {\r\n      coordinates.push(this.parsePoint_());\r\n    }\r\n    return coordinates;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Array<number>>} An array of points.\r\n   * @private\r\n   */\r\n  parsePointTextList_() {\r\n    const coordinates = [this.parsePointText_()];\r\n    while (this.match(TokenType.COMMA)) {\r\n      coordinates.push(this.parsePointText_());\r\n    }\r\n    return coordinates;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Array<Array<number>>>} An array of points.\r\n   * @private\r\n   */\r\n  parseLineStringTextList_() {\r\n    const coordinates = [this.parseLineStringText_()];\r\n    while (this.match(TokenType.COMMA)) {\r\n      coordinates.push(this.parseLineStringText_());\r\n    }\r\n    return coordinates;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Array<Array<Array<number>>>>} An array of points.\r\n   * @private\r\n   */\r\n  parsePolygonTextList_() {\r\n    const coordinates = [this.parsePolygonText_()];\r\n    while (this.match(TokenType.COMMA)) {\r\n      coordinates.push(this.parsePolygonText_());\r\n    }\r\n    return coordinates;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Whether the token implies an empty geometry.\r\n   * @private\r\n   */\r\n  isEmptyGeometry_() {\r\n    const isEmpty =\r\n      this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;\r\n    if (isEmpty) {\r\n      this.consume_();\r\n    }\r\n    return isEmpty;\r\n  }\r\n\r\n  /**\r\n   * Create an error message for an unexpected token error.\r\n   * @return {string} Error message.\r\n   * @private\r\n   */\r\n  formatErrorMessage_() {\r\n    return (\r\n      'Unexpected `' +\r\n      this.token_.value +\r\n      '` at position ' +\r\n      this.token_.position +\r\n      ' in `' +\r\n      this.lexer_.wkt +\r\n      '`'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\r\n   * @private\r\n   */\r\n  parseGeometry_() {\r\n    const token = this.token_;\r\n    if (this.match(TokenType.TEXT)) {\r\n      const geomType = /** @type {string} */ (token.value);\r\n      this.layout_ = this.parseGeometryLayout_();\r\n      const isEmpty = this.isEmptyGeometry_();\r\n      if (geomType == 'GEOMETRYCOLLECTION') {\r\n        if (isEmpty) {\r\n          return new GeometryCollection([]);\r\n        }\r\n        const geometries = this.parseGeometryCollectionText_();\r\n        return new GeometryCollection(geometries);\r\n      }\r\n      const ctor = GeometryConstructor[geomType];\r\n      if (!ctor) {\r\n        throw new Error('Invalid geometry type: ' + geomType);\r\n      }\r\n\r\n      let coordinates;\r\n\r\n      if (isEmpty) {\r\n        if (geomType == 'POINT') {\r\n          coordinates = [NaN, NaN];\r\n        } else {\r\n          coordinates = [];\r\n        }\r\n      } else {\r\n        switch (geomType) {\r\n          case 'POINT': {\r\n            coordinates = this.parsePointText_();\r\n            break;\r\n          }\r\n          case 'LINESTRING': {\r\n            coordinates = this.parseLineStringText_();\r\n            break;\r\n          }\r\n          case 'POLYGON': {\r\n            coordinates = this.parsePolygonText_();\r\n            break;\r\n          }\r\n          case 'MULTIPOINT': {\r\n            coordinates = this.parseMultiPointText_();\r\n            break;\r\n          }\r\n          case 'MULTILINESTRING': {\r\n            coordinates = this.parseMultiLineStringText_();\r\n            break;\r\n          }\r\n          case 'MULTIPOLYGON': {\r\n            coordinates = this.parseMultiPolygonText_();\r\n            break;\r\n          }\r\n          default:\r\n            break;\r\n        }\r\n      }\r\n\r\n      return new ctor(coordinates, this.layout_);\r\n    }\r\n    throw new Error(this.formatErrorMessage_());\r\n  }\r\n}\r\n\r\n/**\r\n * @classdesc\r\n * Geometry format for reading and writing data in the `WellKnownText` (WKT)\r\n * format.\r\n *\r\n * @api\r\n */\r\nclass WKT extends TextFeature {\r\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    options = options ? options : {};\r\n\r\n    /**\r\n     * Split GeometryCollection into multiple features.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.splitCollection_ =\r\n      options.splitCollection !== undefined ? options.splitCollection : false;\r\n  }\r\n\r\n  /**\r\n   * Parse a WKT string.\r\n   * @param {string} wkt WKT string.\r\n   * @return {import(\"../geom/Geometry.js\").default}\r\n   *     The geometry created.\r\n   * @private\r\n   */\r\n  parse_(wkt) {\r\n    const lexer = new Lexer(wkt);\r\n    const parser = new Parser(lexer);\r\n    return parser.parse();\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {string} text Text.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\r\n   * @return {import(\"../Feature.js\").default} Feature.\r\n   */\r\n  readFeatureFromText(text, options) {\r\n    const geom = this.readGeometryFromText(text, options);\r\n    const feature = new Feature();\r\n    feature.setGeometry(geom);\r\n    return feature;\r\n  }\r\n\r\n  /**\r\n   * @param {string} text Text.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\r\n   * @protected\r\n   * @return {Array<Feature>} Features.\r\n   */\r\n  readFeaturesFromText(text, options) {\r\n    let geometries = [];\r\n    const geometry = this.readGeometryFromText(text, options);\r\n    if (this.splitCollection_ && geometry.getType() == 'GeometryCollection') {\r\n      geometries = /** @type {GeometryCollection} */ (\r\n        geometry\r\n      ).getGeometriesArray();\r\n    } else {\r\n      geometries = [geometry];\r\n    }\r\n    const features = [];\r\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\r\n      const feature = new Feature();\r\n      feature.setGeometry(geometries[i]);\r\n      features.push(feature);\r\n    }\r\n    return features;\r\n  }\r\n\r\n  /**\r\n   * @param {string} text Text.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\r\n   * @protected\r\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\r\n   */\r\n  readGeometryFromText(text, options) {\r\n    const geometry = this.parse_(text);\r\n    return transformGeometryWithOptions(geometry, false, options);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Feature.js\").default} feature Features.\r\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\r\n   * @protected\r\n   * @return {string} Text.\r\n   */\r\n  writeFeatureText(feature, options) {\r\n    const geometry = feature.getGeometry();\r\n    if (geometry) {\r\n      return this.writeGeometryText(geometry, options);\r\n    }\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\r\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\r\n   * @protected\r\n   * @return {string} Text.\r\n   */\r\n  writeFeaturesText(features, options) {\r\n    if (features.length == 1) {\r\n      return this.writeFeatureText(features[0], options);\r\n    }\r\n    const geometries = [];\r\n    for (let i = 0, ii = features.length; i < ii; ++i) {\r\n      geometries.push(features[i].getGeometry());\r\n    }\r\n    const collection = new GeometryCollection(geometries);\r\n    return this.writeGeometryText(collection, options);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\r\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\r\n   * @protected\r\n   * @return {string} Text.\r\n   */\r\n  writeGeometryText(geometry, options) {\r\n    return encode(transformGeometryWithOptions(geometry, true, options));\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Point} geom Point geometry.\r\n * @return {string} Coordinates part of Point as WKT.\r\n */\r\nfunction encodePointGeometry(geom) {\r\n  const coordinates = geom.getCoordinates();\r\n  if (coordinates.length === 0) {\r\n    return '';\r\n  }\r\n  return coordinates.join(' ');\r\n}\r\n\r\n/**\r\n * @param {MultiPoint} geom MultiPoint geometry.\r\n * @return {string} Coordinates part of MultiPoint as WKT.\r\n */\r\nfunction encodeMultiPointGeometry(geom) {\r\n  const array = [];\r\n  const components = geom.getPoints();\r\n  for (let i = 0, ii = components.length; i < ii; ++i) {\r\n    array.push('(' + encodePointGeometry(components[i]) + ')');\r\n  }\r\n  return array.join(',');\r\n}\r\n\r\n/**\r\n * @param {GeometryCollection} geom GeometryCollection geometry.\r\n * @return {string} Coordinates part of GeometryCollection as WKT.\r\n */\r\nfunction encodeGeometryCollectionGeometry(geom) {\r\n  const array = [];\r\n  const geoms = geom.getGeometries();\r\n  for (let i = 0, ii = geoms.length; i < ii; ++i) {\r\n    array.push(encode(geoms[i]));\r\n  }\r\n  return array.join(',');\r\n}\r\n\r\n/**\r\n * @param {LineString|import(\"../geom/LinearRing.js\").default} geom LineString geometry.\r\n * @return {string} Coordinates part of LineString as WKT.\r\n */\r\nfunction encodeLineStringGeometry(geom) {\r\n  const coordinates = geom.getCoordinates();\r\n  const array = [];\r\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n    array.push(coordinates[i].join(' '));\r\n  }\r\n  return array.join(',');\r\n}\r\n\r\n/**\r\n * @param {MultiLineString} geom MultiLineString geometry.\r\n * @return {string} Coordinates part of MultiLineString as WKT.\r\n */\r\nfunction encodeMultiLineStringGeometry(geom) {\r\n  const array = [];\r\n  const components = geom.getLineStrings();\r\n  for (let i = 0, ii = components.length; i < ii; ++i) {\r\n    array.push('(' + encodeLineStringGeometry(components[i]) + ')');\r\n  }\r\n  return array.join(',');\r\n}\r\n\r\n/**\r\n * @param {Polygon} geom Polygon geometry.\r\n * @return {string} Coordinates part of Polygon as WKT.\r\n */\r\nfunction encodePolygonGeometry(geom) {\r\n  const array = [];\r\n  const rings = geom.getLinearRings();\r\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\r\n    array.push('(' + encodeLineStringGeometry(rings[i]) + ')');\r\n  }\r\n  return array.join(',');\r\n}\r\n\r\n/**\r\n * @param {MultiPolygon} geom MultiPolygon geometry.\r\n * @return {string} Coordinates part of MultiPolygon as WKT.\r\n */\r\nfunction encodeMultiPolygonGeometry(geom) {\r\n  const array = [];\r\n  const components = geom.getPolygons();\r\n  for (let i = 0, ii = components.length; i < ii; ++i) {\r\n    array.push('(' + encodePolygonGeometry(components[i]) + ')');\r\n  }\r\n  return array.join(',');\r\n}\r\n\r\n/**\r\n * @param {import(\"../geom/SimpleGeometry.js\").default} geom SimpleGeometry geometry.\r\n * @return {string} Potential dimensional information for WKT type.\r\n */\r\nfunction encodeGeometryLayout(geom) {\r\n  const layout = geom.getLayout();\r\n  let dimInfo = '';\r\n  if (layout === 'XYZ' || layout === 'XYZM') {\r\n    dimInfo += Z;\r\n  }\r\n  if (layout === 'XYM' || layout === 'XYZM') {\r\n    dimInfo += M;\r\n  }\r\n  return dimInfo;\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, function(import(\"../geom/Geometry.js\").default): string>}\r\n */\r\nconst GeometryEncoder = {\r\n  'Point': encodePointGeometry,\r\n  'LineString': encodeLineStringGeometry,\r\n  'Polygon': encodePolygonGeometry,\r\n  'MultiPoint': encodeMultiPointGeometry,\r\n  'MultiLineString': encodeMultiLineStringGeometry,\r\n  'MultiPolygon': encodeMultiPolygonGeometry,\r\n  'GeometryCollection': encodeGeometryCollectionGeometry,\r\n};\r\n\r\n/**\r\n * Encode a geometry as WKT.\r\n * @param {import(\"../geom/Geometry.js\").default} geom The geometry to encode.\r\n * @return {string} WKT string for the geometry.\r\n */\r\nfunction encode(geom) {\r\n  const type = geom.getType();\r\n  const geometryEncoder = GeometryEncoder[type];\r\n  const enc = geometryEncoder(geom);\r\n  let wktType = wktTypeLookup[type];\r\n  if (typeof (/** @type {?} */ (geom).getFlatCoordinates) === 'function') {\r\n    const dimInfo = encodeGeometryLayout(\r\n      /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geom)\r\n    );\r\n    if (dimInfo.length > 0) {\r\n      wktType += ' ' + dimInfo;\r\n    }\r\n  }\r\n  if (enc.length === 0) {\r\n    return wktType + ' ' + EMPTY;\r\n  }\r\n  return wktType + '(' + enc + ')';\r\n}\r\n\r\nexport default WKT;\r\n"],
  "mappings": "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",
  "names": ["Feature_default"]
}
