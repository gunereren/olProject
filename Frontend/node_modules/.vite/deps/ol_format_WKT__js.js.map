{
  "version": 3,
  "sources": ["../../ol/format/TextFeature.js", "../../ol/format/WKT.js"],
  "sourcesContent": ["/**\n * @module ol/format/TextFeature\n */\nimport FeatureFormat from '../format/Feature.js';\nimport {abstract} from '../util.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for text feature formats.\n *\n * @abstract\n */\nclass TextFeature extends FeatureFormat {\n  constructor() {\n    super();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   */\n  getType() {\n    return 'text';\n  }\n\n  /**\n   * Read the feature from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  readFeature(source, options) {\n    return this.readFeatureFromText(\n      getText(source),\n      this.adaptOptions(options)\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromText(text, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the features from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  readFeatures(source, options) {\n    return this.readFeaturesFromText(\n      getText(source),\n      this.adaptOptions(options)\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromText(text, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the geometry from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   */\n  readGeometry(source, options) {\n    return this.readGeometryFromText(\n      getText(source),\n      this.adaptOptions(options)\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromText(text, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   * @api\n   */\n  readProjection(source) {\n    return this.readProjectionFromText(getText(source));\n  }\n\n  /**\n   * @param {string} text Text.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   */\n  readProjectionFromText(text) {\n    return this.dataProjection;\n  }\n\n  /**\n   * Encode a feature as a string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   * @api\n   */\n  writeFeature(feature, options) {\n    return this.writeFeatureText(feature, this.adaptOptions(options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../Feature.js\").default} feature Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeatureText(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded features.\n   * @api\n   */\n  writeFeatures(features, options) {\n    return this.writeFeaturesText(features, this.adaptOptions(options));\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeaturesText(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Write a single geometry.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Geometry.\n   * @api\n   */\n  writeGeometry(geometry, options) {\n    return this.writeGeometryText(geometry, this.adaptOptions(options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeGeometryText(geometry, options) {\n    return abstract();\n  }\n}\n\n/**\n * @param {Document|Element|Object|string} source Source.\n * @return {string} Text.\n */\nfunction getText(source) {\n  if (typeof source === 'string') {\n    return source;\n  }\n  return '';\n}\n\nexport default TextFeature;\n", "/**\n * @module ol/format/WKT\n */\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport TextFeature from './TextFeature.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * Geometry constructors\n * @enum {function (new:import(\"../geom/Geometry.js\").default, Array, import(\"../geom/Geometry.js\").GeometryLayout)}\n */\nconst GeometryConstructor = {\n  'POINT': Point,\n  'LINESTRING': LineString,\n  'POLYGON': Polygon,\n  'MULTIPOINT': MultiPoint,\n  'MULTILINESTRING': MultiLineString,\n  'MULTIPOLYGON': MultiPolygon,\n};\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into\n * multiple features on reading.\n */\n\n/**\n * @typedef {Object} Token\n * @property {number} type Type.\n * @property {number|string} [value] Value.\n * @property {number} position Position.\n */\n\n/**\n * @const\n * @type {string}\n */\nconst EMPTY = 'EMPTY';\n\n/**\n * @const\n * @type {string}\n */\nconst Z = 'Z';\n\n/**\n * @const\n * @type {string}\n */\nconst M = 'M';\n\n/**\n * @const\n * @type {string}\n */\nconst ZM = 'ZM';\n\n/**\n * @const\n * @enum {number}\n */\nconst TokenType = {\n  START: 0,\n  TEXT: 1,\n  LEFT_PAREN: 2,\n  RIGHT_PAREN: 3,\n  NUMBER: 4,\n  COMMA: 5,\n  EOF: 6,\n};\n\n/**\n * @type {Object<import(\"../geom/Geometry.js\").Type, string>}\n */\nconst wktTypeLookup = {\n  Point: 'POINT',\n  LineString: 'LINESTRING',\n  Polygon: 'POLYGON',\n  MultiPoint: 'MULTIPOINT',\n  MultiLineString: 'MULTILINESTRING',\n  MultiPolygon: 'MULTIPOLYGON',\n  GeometryCollection: 'GEOMETRYCOLLECTION',\n  Circle: 'CIRCLE',\n};\n\n/**\n * Class to tokenize a WKT string.\n */\nclass Lexer {\n  /**\n   * @param {string} wkt WKT string.\n   */\n  constructor(wkt) {\n    /**\n     * @type {string}\n     */\n    this.wkt = wkt;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.index_ = -1;\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is alphabetic.\n   * @private\n   */\n  isAlpha_(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n  }\n\n  /**\n   * @param {string} c Character.\n   * @param {boolean} [decimal] Whether the string number\n   *     contains a dot, i.e. is a decimal number.\n   * @return {boolean} Whether the character is numeric.\n   * @private\n   */\n  isNumeric_(c, decimal) {\n    decimal = decimal !== undefined ? decimal : false;\n    return (c >= '0' && c <= '9') || (c == '.' && !decimal);\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is whitespace.\n   * @private\n   */\n  isWhiteSpace_(c) {\n    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n  }\n\n  /**\n   * @return {string} Next string character.\n   * @private\n   */\n  nextChar_() {\n    return this.wkt.charAt(++this.index_);\n  }\n\n  /**\n   * Fetch and return the next token.\n   * @return {Token} Next string token.\n   */\n  nextToken() {\n    const c = this.nextChar_();\n    const position = this.index_;\n    /** @type {number|string} */\n    let value = c;\n    let type;\n\n    if (c == '(') {\n      type = TokenType.LEFT_PAREN;\n    } else if (c == ',') {\n      type = TokenType.COMMA;\n    } else if (c == ')') {\n      type = TokenType.RIGHT_PAREN;\n    } else if (this.isNumeric_(c) || c == '-') {\n      type = TokenType.NUMBER;\n      value = this.readNumber_();\n    } else if (this.isAlpha_(c)) {\n      type = TokenType.TEXT;\n      value = this.readText_();\n    } else if (this.isWhiteSpace_(c)) {\n      return this.nextToken();\n    } else if (c === '') {\n      type = TokenType.EOF;\n    } else {\n      throw new Error('Unexpected character: ' + c);\n    }\n\n    return {position: position, value: value, type: type};\n  }\n\n  /**\n   * @return {number} Numeric token value.\n   * @private\n   */\n  readNumber_() {\n    let c;\n    const index = this.index_;\n    let decimal = false;\n    let scientificNotation = false;\n    do {\n      if (c == '.') {\n        decimal = true;\n      } else if (c == 'e' || c == 'E') {\n        scientificNotation = true;\n      }\n      c = this.nextChar_();\n    } while (\n      this.isNumeric_(c, decimal) ||\n      // if we haven't detected a scientific number before, 'e' or 'E'\n      // hint that we should continue to read\n      (!scientificNotation && (c == 'e' || c == 'E')) ||\n      // once we know that we have a scientific number, both '-' and '+'\n      // are allowed\n      (scientificNotation && (c == '-' || c == '+'))\n    );\n    return parseFloat(this.wkt.substring(index, this.index_--));\n  }\n\n  /**\n   * @return {string} String token value.\n   * @private\n   */\n  readText_() {\n    let c;\n    const index = this.index_;\n    do {\n      c = this.nextChar_();\n    } while (this.isAlpha_(c));\n    return this.wkt.substring(index, this.index_--).toUpperCase();\n  }\n}\n\n/**\n * Class to parse the tokens from the WKT string.\n */\nclass Parser {\n  /**\n   * @param {Lexer} lexer The lexer.\n   */\n  constructor(lexer) {\n    /**\n     * @type {Lexer}\n     * @private\n     */\n    this.lexer_ = lexer;\n\n    /**\n     * @type {Token}\n     * @private\n     */\n    this.token_ = {\n      position: 0,\n      type: TokenType.START,\n    };\n\n    /**\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     * @private\n     */\n    this.layout_ = 'XY';\n  }\n\n  /**\n   * Fetch the next token form the lexer and replace the active token.\n   * @private\n   */\n  consume_() {\n    this.token_ = this.lexer_.nextToken();\n  }\n\n  /**\n   * Tests if the given type matches the type of the current token.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  isTokenType(type) {\n    return this.token_.type == type;\n  }\n\n  /**\n   * If the given type matches the current token, consume it.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  match(type) {\n    const isMatch = this.isTokenType(type);\n    if (isMatch) {\n      this.consume_();\n    }\n    return isMatch;\n  }\n\n  /**\n   * Try to parse the tokens provided by the lexer.\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   */\n  parse() {\n    this.consume_();\n    return this.parseGeometry_();\n  }\n\n  /**\n   * Try to parse the dimensional info.\n   * @return {import(\"../geom/Geometry.js\").GeometryLayout} The layout.\n   * @private\n   */\n  parseGeometryLayout_() {\n    /** @type {import(\"../geom/Geometry.js\").GeometryLayout} */\n    let layout = 'XY';\n    const dimToken = this.token_;\n    if (this.isTokenType(TokenType.TEXT)) {\n      const dimInfo = dimToken.value;\n      if (dimInfo === Z) {\n        layout = 'XYZ';\n      } else if (dimInfo === M) {\n        layout = 'XYM';\n      } else if (dimInfo === ZM) {\n        layout = 'XYZM';\n      }\n      if (layout !== 'XY') {\n        this.consume_();\n      }\n    }\n    return layout;\n  }\n\n  /**\n   * @return {Array<import(\"../geom/Geometry.js\").default>} A collection of geometries.\n   * @private\n   */\n  parseGeometryCollectionText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const geometries = [];\n      do {\n        geometries.push(this.parseGeometry_());\n      } while (this.match(TokenType.COMMA));\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return geometries;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<number>} All values in a point.\n   * @private\n   */\n  parsePointText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePoint_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} All points in a linestring.\n   * @private\n   */\n  parseLineStringText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePointList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} All points in a polygon.\n   * @private\n   */\n  parsePolygonText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parseLineStringTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} All points in a multipoint.\n   * @private\n   */\n  parseMultiPointText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      let coordinates;\n      if (this.token_.type == TokenType.LEFT_PAREN) {\n        coordinates = this.parsePointTextList_();\n      } else {\n        coordinates = this.parsePointList_();\n      }\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} All linestring points\n   *                                          in a multilinestring.\n   * @private\n   */\n  parseMultiLineStringText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parseLineStringTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<Array<number>>>>} All polygon points in a multipolygon.\n   * @private\n   */\n  parseMultiPolygonText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePolygonTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<number>} A point.\n   * @private\n   */\n  parsePoint_() {\n    const coordinates = [];\n    const dimensions = this.layout_.length;\n    for (let i = 0; i < dimensions; ++i) {\n      const token = this.token_;\n      if (this.match(TokenType.NUMBER)) {\n        coordinates.push(/** @type {number} */ (token.value));\n      } else {\n        break;\n      }\n    }\n    if (coordinates.length == dimensions) {\n      return coordinates;\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} An array of points.\n   * @private\n   */\n  parsePointList_() {\n    const coordinates = [this.parsePoint_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePoint_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<number>>} An array of points.\n   * @private\n   */\n  parsePointTextList_() {\n    const coordinates = [this.parsePointText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePointText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} An array of points.\n   * @private\n   */\n  parseLineStringTextList_() {\n    const coordinates = [this.parseLineStringText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parseLineStringText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<Array<Array<number>>>>} An array of points.\n   * @private\n   */\n  parsePolygonTextList_() {\n    const coordinates = [this.parsePolygonText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePolygonText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {boolean} Whether the token implies an empty geometry.\n   * @private\n   */\n  isEmptyGeometry_() {\n    const isEmpty =\n      this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;\n    if (isEmpty) {\n      this.consume_();\n    }\n    return isEmpty;\n  }\n\n  /**\n   * Create an error message for an unexpected token error.\n   * @return {string} Error message.\n   * @private\n   */\n  formatErrorMessage_() {\n    return (\n      'Unexpected `' +\n      this.token_.value +\n      '` at position ' +\n      this.token_.position +\n      ' in `' +\n      this.lexer_.wkt +\n      '`'\n    );\n  }\n\n  /**\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   * @private\n   */\n  parseGeometry_() {\n    const token = this.token_;\n    if (this.match(TokenType.TEXT)) {\n      const geomType = /** @type {string} */ (token.value);\n      this.layout_ = this.parseGeometryLayout_();\n      const isEmpty = this.isEmptyGeometry_();\n      if (geomType == 'GEOMETRYCOLLECTION') {\n        if (isEmpty) {\n          return new GeometryCollection([]);\n        }\n        const geometries = this.parseGeometryCollectionText_();\n        return new GeometryCollection(geometries);\n      }\n      const ctor = GeometryConstructor[geomType];\n      if (!ctor) {\n        throw new Error('Invalid geometry type: ' + geomType);\n      }\n\n      let coordinates;\n\n      if (isEmpty) {\n        if (geomType == 'POINT') {\n          coordinates = [NaN, NaN];\n        } else {\n          coordinates = [];\n        }\n      } else {\n        switch (geomType) {\n          case 'POINT': {\n            coordinates = this.parsePointText_();\n            break;\n          }\n          case 'LINESTRING': {\n            coordinates = this.parseLineStringText_();\n            break;\n          }\n          case 'POLYGON': {\n            coordinates = this.parsePolygonText_();\n            break;\n          }\n          case 'MULTIPOINT': {\n            coordinates = this.parseMultiPointText_();\n            break;\n          }\n          case 'MULTILINESTRING': {\n            coordinates = this.parseMultiLineStringText_();\n            break;\n          }\n          case 'MULTIPOLYGON': {\n            coordinates = this.parseMultiPolygonText_();\n            break;\n          }\n          default:\n            break;\n        }\n      }\n\n      return new ctor(coordinates, this.layout_);\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n}\n\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `WellKnownText` (WKT)\n * format.\n *\n * @api\n */\nclass WKT extends TextFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * Split GeometryCollection into multiple features.\n     * @type {boolean}\n     * @private\n     */\n    this.splitCollection_ =\n      options.splitCollection !== undefined ? options.splitCollection : false;\n  }\n\n  /**\n   * Parse a WKT string.\n   * @param {string} wkt WKT string.\n   * @return {import(\"../geom/Geometry.js\").default}\n   *     The geometry created.\n   * @private\n   */\n  parse_(wkt) {\n    const lexer = new Lexer(wkt);\n    const parser = new Parser(lexer);\n    return parser.parse();\n  }\n\n  /**\n   * @protected\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromText(text, options) {\n    const geom = this.readGeometryFromText(text, options);\n    const feature = new Feature();\n    feature.setGeometry(geom);\n    return feature;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromText(text, options) {\n    let geometries = [];\n    const geometry = this.readGeometryFromText(text, options);\n    if (this.splitCollection_ && geometry.getType() == 'GeometryCollection') {\n      geometries = /** @type {GeometryCollection} */ (\n        geometry\n      ).getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    const features = [];\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      const feature = new Feature();\n      feature.setGeometry(geometries[i]);\n      features.push(feature);\n    }\n    return features;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromText(text, options) {\n    const geometry = this.parse_(text);\n    return transformGeometryWithOptions(geometry, false, options);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeatureText(feature, options) {\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      return this.writeGeometryText(geometry, options);\n    }\n    return '';\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeaturesText(features, options) {\n    if (features.length == 1) {\n      return this.writeFeatureText(features[0], options);\n    }\n    const geometries = [];\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      geometries.push(features[i].getGeometry());\n    }\n    const collection = new GeometryCollection(geometries);\n    return this.writeGeometryText(collection, options);\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeGeometryText(geometry, options) {\n    return encode(transformGeometryWithOptions(geometry, true, options));\n  }\n}\n\n/**\n * @param {Point} geom Point geometry.\n * @return {string} Coordinates part of Point as WKT.\n */\nfunction encodePointGeometry(geom) {\n  const coordinates = geom.getCoordinates();\n  if (coordinates.length === 0) {\n    return '';\n  }\n  return coordinates.join(' ');\n}\n\n/**\n * @param {MultiPoint} geom MultiPoint geometry.\n * @return {string} Coordinates part of MultiPoint as WKT.\n */\nfunction encodeMultiPointGeometry(geom) {\n  const array = [];\n  const components = geom.getPoints();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePointGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {GeometryCollection} geom GeometryCollection geometry.\n * @return {string} Coordinates part of GeometryCollection as WKT.\n */\nfunction encodeGeometryCollectionGeometry(geom) {\n  const array = [];\n  const geoms = geom.getGeometries();\n  for (let i = 0, ii = geoms.length; i < ii; ++i) {\n    array.push(encode(geoms[i]));\n  }\n  return array.join(',');\n}\n\n/**\n * @param {LineString|import(\"../geom/LinearRing.js\").default} geom LineString geometry.\n * @return {string} Coordinates part of LineString as WKT.\n */\nfunction encodeLineStringGeometry(geom) {\n  const coordinates = geom.getCoordinates();\n  const array = [];\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    array.push(coordinates[i].join(' '));\n  }\n  return array.join(',');\n}\n\n/**\n * @param {MultiLineString} geom MultiLineString geometry.\n * @return {string} Coordinates part of MultiLineString as WKT.\n */\nfunction encodeMultiLineStringGeometry(geom) {\n  const array = [];\n  const components = geom.getLineStrings();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {Polygon} geom Polygon geometry.\n * @return {string} Coordinates part of Polygon as WKT.\n */\nfunction encodePolygonGeometry(geom) {\n  const array = [];\n  const rings = geom.getLinearRings();\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(rings[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {MultiPolygon} geom MultiPolygon geometry.\n * @return {string} Coordinates part of MultiPolygon as WKT.\n */\nfunction encodeMultiPolygonGeometry(geom) {\n  const array = [];\n  const components = geom.getPolygons();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePolygonGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {import(\"../geom/SimpleGeometry.js\").default} geom SimpleGeometry geometry.\n * @return {string} Potential dimensional information for WKT type.\n */\nfunction encodeGeometryLayout(geom) {\n  const layout = geom.getLayout();\n  let dimInfo = '';\n  if (layout === 'XYZ' || layout === 'XYZM') {\n    dimInfo += Z;\n  }\n  if (layout === 'XYM' || layout === 'XYZM') {\n    dimInfo += M;\n  }\n  return dimInfo;\n}\n\n/**\n * @const\n * @type {Object<string, function(import(\"../geom/Geometry.js\").default): string>}\n */\nconst GeometryEncoder = {\n  'Point': encodePointGeometry,\n  'LineString': encodeLineStringGeometry,\n  'Polygon': encodePolygonGeometry,\n  'MultiPoint': encodeMultiPointGeometry,\n  'MultiLineString': encodeMultiLineStringGeometry,\n  'MultiPolygon': encodeMultiPolygonGeometry,\n  'GeometryCollection': encodeGeometryCollectionGeometry,\n};\n\n/**\n * Encode a geometry as WKT.\n * @param {import(\"../geom/Geometry.js\").default} geom The geometry to encode.\n * @return {string} WKT string for the geometry.\n */\nfunction encode(geom) {\n  const type = geom.getType();\n  const geometryEncoder = GeometryEncoder[type];\n  const enc = geometryEncoder(geom);\n  let wktType = wktTypeLookup[type];\n  if (typeof (/** @type {?} */ (geom).getFlatCoordinates) === 'function') {\n    const dimInfo = encodeGeometryLayout(\n      /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geom)\n    );\n    if (dimInfo.length > 0) {\n      wktType += ' ' + dimInfo;\n    }\n  }\n  if (enc.length === 0) {\n    return wktType + ' ' + EMPTY;\n  }\n  return wktType + '(' + enc + ')';\n}\n\nexport default WKT;\n"],
  "mappings": "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",
  "names": ["Feature_default"]
}
