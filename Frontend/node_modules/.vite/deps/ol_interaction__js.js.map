{
  "version": 3,
  "sources": ["../../ol/interaction/DblClickDragZoom.js", "../../ol/interaction/DragAndDrop.js", "../../ol/interaction/DragRotateAndZoom.js", "../../ol/interaction/Draw.js", "../../ol/interaction/Extent.js", "../../ol/interaction/Link.js", "../../ol/interaction/Modify.js", "../../ol/interaction/Select.js", "../../ol/interaction/Snap.js", "../../ol/interaction/Translate.js"],
  "sourcesContent": ["/**\r\n * @module ol/interaction/DblClickDragZoom\r\n */\r\nimport Interaction from './Interaction.js';\r\nimport MapBrowserEventType from '../MapBrowserEventType.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {number} [duration=400] Animation duration in milliseconds. *\r\n * @property {number} [delta=1] The zoom delta applied on move of one pixel. *\r\n * @property {function(boolean):boolean} [stopDown]\r\n * Should the down event be propagated to other interactions, or should be\r\n * stopped?\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Allows the user to zoom the map by double tap/clik then drag up/down\r\n * with one finger/left mouse.\r\n * @api\r\n */\r\nclass DblClickDragZoom extends Interaction {\r\n  /**\r\n   * @param {Options} [opt_options] Options.\r\n   */\r\n  constructor(opt_options) {\r\n    const options = opt_options ? opt_options : {};\r\n\r\n    super(\r\n      /** @type {import(\"./Interaction.js\").InteractionOptions} */ (options)\r\n    );\r\n\r\n    if (options.stopDown) {\r\n      this.stopDown = options.stopDown;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.scaleDeltaByPixel_ = options.delta ? options.delta : 0.01;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.handlingDownUpSequence_ = false;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.handlingDoubleDownSequence_ = false;\r\n\r\n    /**\r\n     * @type {!Object<string, PointerEvent>}\r\n     * @private\r\n     */\r\n    this.trackedPointers_ = {};\r\n\r\n    /**\r\n     * @type {Array<PointerEvent>}\r\n     * @protected\r\n     */\r\n    this.targetPointers = [];\r\n  }\r\n\r\n  /**\r\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent  map browser event} and may call into\r\n   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are\r\n   * detected.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n   * @return {boolean} `false` to stop event propagation.\r\n   * @api\r\n   */\r\n  handleEvent(mapBrowserEvent) {\r\n    if (!mapBrowserEvent.originalEvent) {\r\n      return true;\r\n    }\r\n\r\n    let stopEvent = false;\r\n    this.updateTrackedPointers_(mapBrowserEvent);\r\n    if (this.handlingDownUpSequence_) {\r\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {\r\n        this.handleDragEvent(mapBrowserEvent);\r\n        // prevent page scrolling during dragging\r\n        mapBrowserEvent.originalEvent.preventDefault();\r\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {\r\n        const handledUp = this.handleUpEvent(mapBrowserEvent);\r\n        this.handlingDownUpSequence_ = handledUp;\r\n      }\r\n    } else {\r\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {\r\n        if (this.handlingDoubleDownSequence_) {\r\n          this.handlingDoubleDownSequence_ = false;\r\n          const handled = this.handleDownEvent(mapBrowserEvent);\r\n          this.handlingDownUpSequence_ = handled;\r\n          stopEvent = this.stopDown(handled);\r\n        } else {\r\n          stopEvent = this.stopDown(false);\r\n          this.waitForDblTap();\r\n        }\r\n      }\r\n    }\r\n    return !stopEvent;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer drag events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   */\r\n  handleDragEvent(mapBrowserEvent) {\r\n    let scaleDelta = 1.0;\r\n\r\n    const touch0 = this.targetPointers[0];\r\n    const touch1 = this.down_.originalEvent;\r\n    const distance = touch0.clientY - touch1.clientY;\r\n\r\n    if (this.lastDistance_ !== undefined) {\r\n      scaleDelta =\r\n        1 - (this.lastDistance_ - distance) * this.scaleDeltaByPixel_;\r\n    }\r\n    this.lastDistance_ = distance;\r\n\r\n    if (scaleDelta != 1.0) {\r\n      this.lastScaleDelta_ = scaleDelta;\r\n    }\r\n\r\n    // scale, bypass the resolution constraint\r\n    const map = mapBrowserEvent.map;\r\n    const view = map.getView();\r\n    map.render();\r\n    view.adjustResolutionInternal(scaleDelta);\r\n  }\r\n\r\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleDownEvent(mapBrowserEvent) {\r\n    if (this.targetPointers.length == 1) {\r\n      const map = mapBrowserEvent.map;\r\n      this.anchor_ = null;\r\n      this.lastDistance_ = undefined;\r\n      this.lastScaleDelta_ = 1;\r\n      this.down_ = mapBrowserEvent;\r\n      if (!this.handlingDownUpSequence_) {\r\n        map.getView().beginInteraction();\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer up events zooming out.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleUpEvent(mapBrowserEvent) {\r\n    if (this.targetPointers.length == 0) {\r\n      const map = mapBrowserEvent.map;\r\n      const view = map.getView();\r\n      const direction = this.lastScaleDelta_ > 1 ? 1 : -1;\r\n      view.endInteraction(this.duration_, direction);\r\n      this.handlingDownUpSequence_ = false;\r\n      this.handlingDoubleDownSequence_ = false;\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * This function is used to determine if \"down\" events should be propagated\r\n   * to other interactions or should be stopped.\r\n   * @param {boolean} handled Was the event handled by the interaction?\r\n   * @return {boolean} Should the `down` event be stopped?\r\n   */\r\n  stopDown(handled) {\r\n    return handled;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @private\r\n   */\r\n  updateTrackedPointers_(mapBrowserEvent) {\r\n    if (isPointerDraggingEvent(mapBrowserEvent)) {\r\n      const event = mapBrowserEvent.originalEvent;\r\n\r\n      const id = event.pointerId.toString();\r\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {\r\n        delete this.trackedPointers_[id];\r\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {\r\n        this.trackedPointers_[id] = event;\r\n      } else if (id in this.trackedPointers_) {\r\n        // update only when there was a pointerdown event for this pointer\r\n        this.trackedPointers_[id] = event;\r\n      }\r\n      this.targetPointers = Object.values(this.trackedPointers_);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Wait the second double finger tap.\r\n   */\r\n  waitForDblTap() {\r\n    if (this.doubleTapTimeoutId_ !== undefined) {\r\n      // double-click\r\n      clearTimeout(this.doubleTapTimeoutId_);\r\n      this.doubleTapTimeoutId_ = undefined;\r\n    } else {\r\n      this.handlingDoubleDownSequence_ = true;\r\n      this.doubleTapTimeoutId_ = setTimeout(\r\n        this.endInteraction.bind(this),\r\n        250\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  endInteraction() {\r\n    this.handlingDoubleDownSequence_ = false;\r\n    this.doubleTapTimeoutId_ = undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n * @return {boolean} Whether the event is a pointerdown, pointerdrag\r\n *     or pointerup event.\r\n */\r\nfunction isPointerDraggingEvent(mapBrowserEvent) {\r\n  const type = mapBrowserEvent.type;\r\n  return (\r\n    type === MapBrowserEventType.POINTERDOWN ||\r\n    type === MapBrowserEventType.POINTERDRAG ||\r\n    type === MapBrowserEventType.POINTERUP\r\n  );\r\n}\r\n\r\nexport default DblClickDragZoom;\r\n", "/**\r\n * @module ol/interaction/DragAndDrop\r\n */\r\n// FIXME should handle all geo-referenced data, not just vector data\r\n\r\nimport Event from '../events/Event.js';\r\nimport EventType from '../events/EventType.js';\r\nimport Interaction from './Interaction.js';\r\nimport {TRUE} from '../functions.js';\r\nimport {get as getProjection, getUserProjection} from '../proj.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Array<typeof import(\"../format/Feature.js\").default|import(\"../format/Feature.js\").default>} [formatConstructors] Format constructors\r\n * (and/or formats pre-constructed with options).\r\n * @property {import(\"../source/Vector.js\").default} [source] Optional vector source where features will be added.  If a source is provided\r\n * all existing features will be removed and new features will be added when\r\n * they are dropped on the target.  If you want to add features to a vector\r\n * source without removing the existing features (append only), instead of\r\n * providing the source option listen for the \"addfeatures\" event.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.\r\n * @property {HTMLElement} [target] The element that is used as the drop target, default is the viewport element.\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nconst DragAndDropEventType = {\r\n  /**\r\n   * Triggered when features are added\r\n   * @event DragAndDropEvent#addfeatures\r\n   * @api\r\n   */\r\n  ADD_FEATURES: 'addfeatures',\r\n};\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances\r\n * of this type.\r\n */\r\nexport class DragAndDropEvent extends Event {\r\n  /**\r\n   * @param {DragAndDropEventType} type Type.\r\n   * @param {File} file File.\r\n   * @param {Array<import(\"../Feature.js\").default>} [features] Features.\r\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\r\n   */\r\n  constructor(type, file, features, projection) {\r\n    super(type);\r\n\r\n    /**\r\n     * The features parsed from dropped data.\r\n     * @type {Array<import(\"../Feature.js\").FeatureLike>|undefined}\r\n     * @api\r\n     */\r\n    this.features = features;\r\n\r\n    /**\r\n     * The dropped file.\r\n     * @type {File}\r\n     * @api\r\n     */\r\n    this.file = file;\r\n\r\n    /**\r\n     * The feature projection.\r\n     * @type {import(\"../proj/Projection.js\").default|undefined}\r\n     * @api\r\n     */\r\n    this.projection = projection;\r\n  }\r\n}\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\r\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<'addfeatures', DragAndDropEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\r\n *     'change:active'|'addfeatures', Return>} DragAndDropOnSignature\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Handles input of vector data by drag and drop.\r\n *\r\n * @api\r\n *\r\n * @fires DragAndDropEvent\r\n */\r\nclass DragAndDrop extends Interaction {\r\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? options : {};\r\n\r\n    super({\r\n      handleEvent: TRUE,\r\n    });\r\n\r\n    /***\r\n     * @type {DragAndDropOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {DragAndDropOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {DragAndDropOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.readAsBuffer_ = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<import(\"../format/Feature.js\").default>}\r\n     */\r\n    this.formats_ = [];\r\n    const formatConstructors = options.formatConstructors\r\n      ? options.formatConstructors\r\n      : [];\r\n    for (let i = 0, ii = formatConstructors.length; i < ii; ++i) {\r\n      let format = formatConstructors[i];\r\n      if (typeof format === 'function') {\r\n        format = new format();\r\n      }\r\n      this.formats_.push(format);\r\n      this.readAsBuffer_ =\r\n        this.readAsBuffer_ || format.getType() === 'arraybuffer';\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     */\r\n    this.projection_ = options.projection\r\n      ? getProjection(options.projection)\r\n      : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Array<import(\"../events.js\").EventsKey>}\r\n     */\r\n    this.dropListenKeys_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../source/Vector.js\").default}\r\n     */\r\n    this.source_ = options.source || null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLElement|null}\r\n     */\r\n    this.target = options.target ? options.target : null;\r\n  }\r\n\r\n  /**\r\n   * @param {File} file File.\r\n   * @param {Event} event Load event.\r\n   * @private\r\n   */\r\n  handleResult_(file, event) {\r\n    const result = event.target.result;\r\n    const map = this.getMap();\r\n    let projection = this.projection_;\r\n    if (!projection) {\r\n      projection = getUserProjection();\r\n      if (!projection) {\r\n        const view = map.getView();\r\n        projection = view.getProjection();\r\n      }\r\n    }\r\n\r\n    let text;\r\n    const formats = this.formats_;\r\n    for (let i = 0, ii = formats.length; i < ii; ++i) {\r\n      const format = formats[i];\r\n      let input = result;\r\n      if (this.readAsBuffer_ && format.getType() !== 'arraybuffer') {\r\n        if (text === undefined) {\r\n          text = new TextDecoder().decode(result);\r\n        }\r\n        input = text;\r\n      }\r\n      const features = this.tryReadFeatures_(format, input, {\r\n        featureProjection: projection,\r\n      });\r\n      if (features && features.length > 0) {\r\n        if (this.source_) {\r\n          this.source_.clear();\r\n          this.source_.addFeatures(features);\r\n        }\r\n        this.dispatchEvent(\r\n          new DragAndDropEvent(\r\n            DragAndDropEventType.ADD_FEATURES,\r\n            file,\r\n            features,\r\n            projection\r\n          )\r\n        );\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  registerListeners_() {\r\n    const map = this.getMap();\r\n    if (map) {\r\n      const dropArea = this.target ? this.target : map.getViewport();\r\n      this.dropListenKeys_ = [\r\n        listen(dropArea, EventType.DROP, this.handleDrop, this),\r\n        listen(dropArea, EventType.DRAGENTER, this.handleStop, this),\r\n        listen(dropArea, EventType.DRAGOVER, this.handleStop, this),\r\n        listen(dropArea, EventType.DROP, this.handleStop, this),\r\n      ];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activate or deactivate the interaction.\r\n   * @param {boolean} active Active.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setActive(active) {\r\n    if (!this.getActive() && active) {\r\n      this.registerListeners_();\r\n    }\r\n    if (this.getActive() && !active) {\r\n      this.unregisterListeners_();\r\n    }\r\n    super.setActive(active);\r\n  }\r\n\r\n  /**\r\n   * Remove the interaction from its current map and attach it to the new map.\r\n   * Subclasses may set up event handlers to get notified about changes to\r\n   * the map here.\r\n   * @param {import(\"../Map.js\").default} map Map.\r\n   */\r\n  setMap(map) {\r\n    this.unregisterListeners_();\r\n    super.setMap(map);\r\n    if (this.getActive()) {\r\n      this.registerListeners_();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../format/Feature.js\").default} format Format.\r\n   * @param {string} text Text.\r\n   * @param {import(\"../format/Feature.js\").ReadOptions} options Read options.\r\n   * @private\r\n   * @return {Array<import(\"../Feature.js\").default>} Features.\r\n   */\r\n  tryReadFeatures_(format, text, options) {\r\n    try {\r\n      return (\r\n        /** @type {Array<import(\"../Feature.js\").default>} */\r\n        (format.readFeatures(text, options))\r\n      );\r\n    } catch (e) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  unregisterListeners_() {\r\n    if (this.dropListenKeys_) {\r\n      this.dropListenKeys_.forEach(unlistenByKey);\r\n      this.dropListenKeys_ = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {DragEvent} event Event.\r\n   */\r\n  handleDrop(event) {\r\n    const files = event.dataTransfer.files;\r\n    for (let i = 0, ii = files.length; i < ii; ++i) {\r\n      const file = files.item(i);\r\n      const reader = new FileReader();\r\n      reader.addEventListener(\r\n        EventType.LOAD,\r\n        this.handleResult_.bind(this, file)\r\n      );\r\n      if (this.readAsBuffer_) {\r\n        reader.readAsArrayBuffer(file);\r\n      } else {\r\n        reader.readAsText(file);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {DragEvent} event Event.\r\n   */\r\n  handleStop(event) {\r\n    event.stopPropagation();\r\n    event.preventDefault();\r\n    event.dataTransfer.dropEffect = 'copy';\r\n  }\r\n}\r\n\r\nexport default DragAndDrop;\r\n", "/**\r\n * @module ol/interaction/DragRotateAndZoom\r\n */\r\nimport PointerInteraction from './Pointer.js';\r\nimport {mouseOnly, shiftKeyOnly} from '../events/condition.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\r\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event should be handled.\r\n * Default is {@link module:ol/events/condition.shiftKeyOnly}.\r\n * @property {number} [duration=400] Animation duration in milliseconds.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Allows the user to zoom and rotate the map by clicking and dragging\r\n * on the map.  By default, this interaction is limited to when the shift\r\n * key is held down.\r\n *\r\n * This interaction is only supported for mouse devices.\r\n *\r\n * And this interaction is not included in the default interactions.\r\n * @api\r\n */\r\nclass DragRotateAndZoom extends PointerInteraction {\r\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? options : {};\r\n\r\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\r\n    this.condition_ = options.condition ? options.condition : shiftKeyOnly;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.lastAngle_ = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.lastMagnitude_ = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.lastScaleDelta_ = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.duration_ = options.duration !== undefined ? options.duration : 400;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer drag events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   */\r\n  handleDragEvent(mapBrowserEvent) {\r\n    if (!mouseOnly(mapBrowserEvent)) {\r\n      return;\r\n    }\r\n\r\n    const map = mapBrowserEvent.map;\r\n    const size = map.getSize();\r\n    const offset = mapBrowserEvent.pixel;\r\n    const deltaX = offset[0] - size[0] / 2;\r\n    const deltaY = size[1] / 2 - offset[1];\r\n    const theta = Math.atan2(deltaY, deltaX);\r\n    const magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n    const view = map.getView();\r\n    if (this.lastAngle_ !== undefined) {\r\n      const angleDelta = this.lastAngle_ - theta;\r\n      view.adjustRotationInternal(angleDelta);\r\n    }\r\n    this.lastAngle_ = theta;\r\n    if (this.lastMagnitude_ !== undefined) {\r\n      view.adjustResolutionInternal(this.lastMagnitude_ / magnitude);\r\n    }\r\n    if (this.lastMagnitude_ !== undefined) {\r\n      this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;\r\n    }\r\n    this.lastMagnitude_ = magnitude;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleUpEvent(mapBrowserEvent) {\r\n    if (!mouseOnly(mapBrowserEvent)) {\r\n      return true;\r\n    }\r\n\r\n    const map = mapBrowserEvent.map;\r\n    const view = map.getView();\r\n    const direction = this.lastScaleDelta_ > 1 ? 1 : -1;\r\n    view.endInteraction(this.duration_, direction);\r\n    this.lastScaleDelta_ = 0;\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleDownEvent(mapBrowserEvent) {\r\n    if (!mouseOnly(mapBrowserEvent)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.condition_(mapBrowserEvent)) {\r\n      mapBrowserEvent.map.getView().beginInteraction();\r\n      this.lastAngle_ = undefined;\r\n      this.lastMagnitude_ = undefined;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nexport default DragRotateAndZoom;\r\n", "/**\r\n * @module ol/interaction/Draw\r\n */\r\nimport Circle from '../geom/Circle.js';\r\nimport Event from '../events/Event.js';\r\nimport EventType from '../events/EventType.js';\r\nimport Feature from '../Feature.js';\r\nimport GeometryCollection from '../geom/GeometryCollection.js';\r\nimport InteractionProperty from './Property.js';\r\nimport LineString from '../geom/LineString.js';\r\nimport MapBrowserEvent from '../MapBrowserEvent.js';\r\nimport MapBrowserEventType from '../MapBrowserEventType.js';\r\nimport MultiLineString from '../geom/MultiLineString.js';\r\nimport MultiPoint from '../geom/MultiPoint.js';\r\nimport MultiPolygon from '../geom/MultiPolygon.js';\r\nimport Point from '../geom/Point.js';\r\nimport PointerInteraction from './Pointer.js';\r\nimport Polygon, {fromCircle, makeRegular} from '../geom/Polygon.js';\r\nimport VectorLayer from '../layer/Vector.js';\r\nimport VectorSource from '../source/Vector.js';\r\nimport {FALSE, TRUE} from '../functions.js';\r\nimport {\r\n  always,\r\n  never,\r\n  noModifierKeys,\r\n  shiftKeyOnly,\r\n} from '../events/condition.js';\r\nimport {\r\n  boundingExtent,\r\n  getBottomLeft,\r\n  getBottomRight,\r\n  getTopLeft,\r\n  getTopRight,\r\n} from '../extent.js';\r\nimport {clamp, squaredDistance, toFixed} from '../math.js';\r\nimport {createEditingStyle} from '../style/Style.js';\r\nimport {\r\n  distance,\r\n  squaredDistance as squaredCoordinateDistance,\r\n} from '../coordinate.js';\r\nimport {fromUserCoordinate, getUserProjection} from '../proj.js';\r\nimport {getStrideForLayout} from '../geom/SimpleGeometry.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\r\n * the geometries being drawn with this instance.\r\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\r\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\r\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\r\n * was chosen for the draw interaction to behave correctly on mouse as well as\r\n * on touch devices.\r\n * @property {import(\"../Collection.js\").default<Feature>} [features]\r\n * Destination collection for the drawn features.\r\n * @property {VectorSource} [source] Destination source for\r\n * the drawn features.\r\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\r\n * before the current vertex can be dragged to its exact position.\r\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\r\n * drawing finish. Must be greater than `0`.\r\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\r\n * doubleclick events from firing during drawing.\r\n * @property {number} [maxPoints] The number of points that can be drawn before\r\n * a polygon ring or line string is finished. By default there is no\r\n * restriction.\r\n * @property {number} [minPoints] The number of points that must be drawn\r\n * before a polygon ring or line string can be finished. Default is `3` for\r\n * polygon rings and `2` for line strings.\r\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\r\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether the drawing can be finished. Not used when drawing\r\n * POINT or MULTI_POINT geometries.\r\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\r\n * Style for sketch features.\r\n * @property {GeometryFunction} [geometryFunction]\r\n * Function that is called when a geometry's coordinates are updated.\r\n * @property {string} [geometryName] Geometry name to use for features created\r\n * by the draw interaction.\r\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\r\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event should be handled.\r\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\r\n * adds a vertex or deactivates freehand drawing.\r\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\r\n * polygons, and circles.  This makes the interaction always operate in freehand\r\n * mode and takes precedence over any `freehandCondition` option.\r\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\r\n * Condition that activates freehand drawing for lines and polygons. This\r\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\r\n * returns a boolean to indicate whether that event should be handled. The\r\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\r\n * Shift key activates freehand drawing.\r\n * @property {boolean|import(\"../events/condition.js\").Condition} [trace=false] Trace a portion of another geometry.\r\n * Ignored when in freehand mode.\r\n * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is\r\n * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with\r\n * either a `traceSource` or a `source`.\r\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\r\n * overlay.\r\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout='XY'] Layout of the\r\n * feature geometries created by the draw interaction.\r\n */\r\n\r\n/**\r\n * Coordinate type when drawing points.\r\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\r\n */\r\n\r\n/**\r\n * Coordinate type when drawing lines.\r\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\r\n */\r\n\r\n/**\r\n * Coordinate type when drawing polygons.\r\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\r\n */\r\n\r\n/**\r\n * Types used for drawing coordinates.\r\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\r\n */\r\n\r\n/**\r\n * @typedef {Object} TraceState\r\n * @property {boolean} active Tracing active.\r\n * @property {import(\"../pixel.js\").Pixel} [startPx] The initially clicked pixel location.\r\n * @property {Array<TraceTarget>} [targets] Targets available for tracing.\r\n * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates\r\n * that no trace target is active.\r\n */\r\n\r\n/**\r\n * @typedef {Object} TraceTarget\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} coordinates Target coordinates.\r\n * @property {boolean} ring The target coordinates are a linear ring.\r\n * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an\r\n * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).\r\n * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.\r\n */\r\n\r\n/**\r\n * Function that takes an array of coordinates and an optional existing geometry\r\n * and a projection as arguments, and returns a geometry. The optional existing\r\n * geometry is the geometry that is returned when the function is called without\r\n * a second argument.\r\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\r\n *     import(\"../proj/Projection.js\").default):\r\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\r\n */\r\n\r\n/**\r\n * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode\r\n * Draw mode.  This collapses multi-part geometry types with their single-part\r\n * cousins.\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nconst DrawEventType = {\r\n  /**\r\n   * Triggered upon feature draw start\r\n   * @event DrawEvent#drawstart\r\n   * @api\r\n   */\r\n  DRAWSTART: 'drawstart',\r\n  /**\r\n   * Triggered upon feature draw end\r\n   * @event DrawEvent#drawend\r\n   * @api\r\n   */\r\n  DRAWEND: 'drawend',\r\n  /**\r\n   * Triggered upon feature draw abortion\r\n   * @event DrawEvent#drawabort\r\n   * @api\r\n   */\r\n  DRAWABORT: 'drawabort',\r\n};\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\r\n * instances of this type.\r\n */\r\nexport class DrawEvent extends Event {\r\n  /**\r\n   * @param {DrawEventType} type Type.\r\n   * @param {Feature} feature The feature drawn.\r\n   */\r\n  constructor(type, feature) {\r\n    super(type);\r\n\r\n    /**\r\n     * The feature being drawn.\r\n     * @type {Feature}\r\n     * @api\r\n     */\r\n    this.feature = feature;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\r\n * @param {Array<Feature>} features The candidate features.\r\n * @return {Array<TraceTarget>} The trace targets.\r\n */\r\nfunction getTraceTargets(coordinate, features) {\r\n  /**\r\n   * @type {Array<TraceTarget>}\r\n   */\r\n  const targets = [];\r\n\r\n  for (let i = 0; i < features.length; ++i) {\r\n    const feature = features[i];\r\n    const geometry = feature.getGeometry();\r\n    appendGeometryTraceTargets(coordinate, geometry, targets);\r\n  }\r\n\r\n  return targets;\r\n}\r\n\r\n/**\r\n * @param {import(\"../coordinate.js\").Coordinate} a One coordinate.\r\n * @param {import(\"../coordinate.js\").Coordinate} b Another coordinate.\r\n * @return {number} The squared distance between the two coordinates.\r\n */\r\nfunction getSquaredDistance(a, b) {\r\n  return squaredDistance(a[0], a[1], b[0], b[1]);\r\n}\r\n\r\n/**\r\n * @param {LineCoordType} coordinates The ring coordinates.\r\n * @param {number} index The index.  May be wrapped.\r\n * @return {import(\"../coordinate.js\").Coordinate} The coordinate.\r\n */\r\nfunction getCoordinate(coordinates, index) {\r\n  const count = coordinates.length;\r\n  if (index < 0) {\r\n    return coordinates[index + count];\r\n  }\r\n  if (index >= count) {\r\n    return coordinates[index - count];\r\n  }\r\n  return coordinates[index];\r\n}\r\n\r\n/**\r\n * Get the cumulative squared distance along a ring path.  The end index index may be \"wrapped\" and it may\r\n * be less than the start index to indicate the direction of travel.  The start and end index may have\r\n * a fractional part to indicate a point between two coordinates.\r\n * @param {LineCoordType} coordinates Ring coordinates.\r\n * @param {number} startIndex The start index.\r\n * @param {number} endIndex The end index.\r\n * @return {number} The cumulative squared distance along the ring path.\r\n */\r\nfunction getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {\r\n  let lowIndex, highIndex;\r\n  if (startIndex < endIndex) {\r\n    lowIndex = startIndex;\r\n    highIndex = endIndex;\r\n  } else {\r\n    lowIndex = endIndex;\r\n    highIndex = startIndex;\r\n  }\r\n  const lowWholeIndex = Math.ceil(lowIndex);\r\n  const highWholeIndex = Math.floor(highIndex);\r\n\r\n  if (lowWholeIndex > highWholeIndex) {\r\n    // both start and end are on the same segment\r\n    const start = interpolateCoordinate(coordinates, lowIndex);\r\n    const end = interpolateCoordinate(coordinates, highIndex);\r\n    return getSquaredDistance(start, end);\r\n  }\r\n\r\n  let sd = 0;\r\n\r\n  if (lowIndex < lowWholeIndex) {\r\n    const start = interpolateCoordinate(coordinates, lowIndex);\r\n    const end = getCoordinate(coordinates, lowWholeIndex);\r\n    sd += getSquaredDistance(start, end);\r\n  }\r\n\r\n  if (highWholeIndex < highIndex) {\r\n    const start = getCoordinate(coordinates, highWholeIndex);\r\n    const end = interpolateCoordinate(coordinates, highIndex);\r\n    sd += getSquaredDistance(start, end);\r\n  }\r\n\r\n  for (let i = lowWholeIndex; i < highWholeIndex - 1; ++i) {\r\n    const start = getCoordinate(coordinates, i);\r\n    const end = getCoordinate(coordinates, i + 1);\r\n    sd += getSquaredDistance(start, end);\r\n  }\r\n\r\n  return sd;\r\n}\r\n\r\n/**\r\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\r\n * @param {import(\"../geom/Geometry.js\").default} geometry The candidate geometry.\r\n * @param {Array<TraceTarget>} targets The trace targets.\r\n */\r\nfunction appendGeometryTraceTargets(coordinate, geometry, targets) {\r\n  if (geometry instanceof LineString) {\r\n    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);\r\n    return;\r\n  }\r\n  if (geometry instanceof MultiLineString) {\r\n    const coordinates = geometry.getCoordinates();\r\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n      appendTraceTarget(coordinate, coordinates[i], false, targets);\r\n    }\r\n    return;\r\n  }\r\n  if (geometry instanceof Polygon) {\r\n    const coordinates = geometry.getCoordinates();\r\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n      appendTraceTarget(coordinate, coordinates[i], true, targets);\r\n    }\r\n    return;\r\n  }\r\n  if (geometry instanceof MultiPolygon) {\r\n    const polys = geometry.getCoordinates();\r\n    for (let i = 0, ii = polys.length; i < ii; ++i) {\r\n      const coordinates = polys[i];\r\n      for (let j = 0, jj = coordinates.length; j < jj; ++j) {\r\n        appendTraceTarget(coordinate, coordinates[j], true, targets);\r\n      }\r\n    }\r\n    return;\r\n  }\r\n  if (geometry instanceof GeometryCollection) {\r\n    const geometries = geometry.getGeometries();\r\n    for (let i = 0; i < geometries.length; ++i) {\r\n      appendGeometryTraceTargets(coordinate, geometries[i], targets);\r\n    }\r\n    return;\r\n  }\r\n  // other types cannot be traced\r\n}\r\n\r\n/**\r\n * @typedef {Object} TraceTargetUpdateInfo\r\n * @property {number} index The new target index.\r\n * @property {number} endIndex The new segment end index.\r\n */\r\n\r\n/**\r\n * @type {TraceTargetUpdateInfo}\r\n */\r\nconst sharedUpdateInfo = {index: -1, endIndex: NaN};\r\n\r\n/**\r\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\r\n * @param {TraceState} traceState The trace state.\r\n * @param {import(\"../Map.js\").default} map The map.\r\n * @param {number} snapTolerance The snap tolerance.\r\n * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned\r\n * object is reused between calls and must not be modified by the caller.\r\n */\r\nfunction getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {\r\n  const x = coordinate[0];\r\n  const y = coordinate[1];\r\n\r\n  let closestTargetDistance = Infinity;\r\n\r\n  let newTargetIndex = -1;\r\n  let newEndIndex = NaN;\r\n\r\n  for (\r\n    let targetIndex = 0;\r\n    targetIndex < traceState.targets.length;\r\n    ++targetIndex\r\n  ) {\r\n    const target = traceState.targets[targetIndex];\r\n    const coordinates = target.coordinates;\r\n\r\n    let minSegmentDistance = Infinity;\r\n    let endIndex;\r\n    for (\r\n      let coordinateIndex = 0;\r\n      coordinateIndex < coordinates.length - 1;\r\n      ++coordinateIndex\r\n    ) {\r\n      const start = coordinates[coordinateIndex];\r\n      const end = coordinates[coordinateIndex + 1];\r\n      const rel = getPointSegmentRelationship(x, y, start, end);\r\n      if (rel.squaredDistance < minSegmentDistance) {\r\n        minSegmentDistance = rel.squaredDistance;\r\n        endIndex = coordinateIndex + rel.along;\r\n      }\r\n    }\r\n\r\n    if (minSegmentDistance < closestTargetDistance) {\r\n      closestTargetDistance = minSegmentDistance;\r\n      if (target.ring && traceState.targetIndex === targetIndex) {\r\n        // same target, maintain the same trace direction\r\n        if (target.endIndex > target.startIndex) {\r\n          // forward trace\r\n          if (endIndex < target.startIndex) {\r\n            endIndex += coordinates.length;\r\n          }\r\n        } else if (target.endIndex < target.startIndex) {\r\n          // reverse trace\r\n          if (endIndex > target.startIndex) {\r\n            endIndex -= coordinates.length;\r\n          }\r\n        }\r\n      }\r\n      newEndIndex = endIndex;\r\n      newTargetIndex = targetIndex;\r\n    }\r\n  }\r\n\r\n  const newTarget = traceState.targets[newTargetIndex];\r\n  let considerBothDirections = newTarget.ring;\r\n  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {\r\n    // only consider switching trace direction if close to the start\r\n    const newCoordinate = interpolateCoordinate(\r\n      newTarget.coordinates,\r\n      newEndIndex\r\n    );\r\n    const pixel = map.getPixelFromCoordinate(newCoordinate);\r\n    if (distance(pixel, traceState.startPx) > snapTolerance) {\r\n      considerBothDirections = false;\r\n    }\r\n  }\r\n\r\n  if (considerBothDirections) {\r\n    const coordinates = newTarget.coordinates;\r\n    const count = coordinates.length;\r\n    const startIndex = newTarget.startIndex;\r\n    const endIndex = newEndIndex;\r\n    if (startIndex < endIndex) {\r\n      const forwardDistance = getCumulativeSquaredDistance(\r\n        coordinates,\r\n        startIndex,\r\n        endIndex\r\n      );\r\n      const reverseDistance = getCumulativeSquaredDistance(\r\n        coordinates,\r\n        startIndex,\r\n        endIndex - count\r\n      );\r\n      if (reverseDistance < forwardDistance) {\r\n        newEndIndex -= count;\r\n      }\r\n    } else {\r\n      const reverseDistance = getCumulativeSquaredDistance(\r\n        coordinates,\r\n        startIndex,\r\n        endIndex\r\n      );\r\n      const forwardDistance = getCumulativeSquaredDistance(\r\n        coordinates,\r\n        startIndex,\r\n        endIndex + count\r\n      );\r\n      if (forwardDistance < reverseDistance) {\r\n        newEndIndex += count;\r\n      }\r\n    }\r\n  }\r\n\r\n  sharedUpdateInfo.index = newTargetIndex;\r\n  sharedUpdateInfo.endIndex = newEndIndex;\r\n  return sharedUpdateInfo;\r\n}\r\n\r\n/**\r\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The clicked coordinate.\r\n * @param {Array<import(\"../coordinate.js\").Coordinate>} coordinates The geometry component coordinates.\r\n * @param {boolean} ring The coordinates represent a linear ring.\r\n * @param {Array<TraceTarget>} targets The trace targets.\r\n */\r\nfunction appendTraceTarget(coordinate, coordinates, ring, targets) {\r\n  const x = coordinate[0];\r\n  const y = coordinate[1];\r\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\r\n    const start = coordinates[i];\r\n    const end = coordinates[i + 1];\r\n    const rel = getPointSegmentRelationship(x, y, start, end);\r\n    if (rel.squaredDistance === 0) {\r\n      const index = i + rel.along;\r\n      targets.push({\r\n        coordinates: coordinates,\r\n        ring: ring,\r\n        startIndex: index,\r\n        endIndex: index,\r\n      });\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef {Object} PointSegmentRelationship\r\n * @property {number} along The closest point expressed as a fraction along the segment length.\r\n * @property {number} squaredDistance The squared distance of the point to the segment.\r\n */\r\n\r\n/**\r\n * @type {PointSegmentRelationship}\r\n */\r\nconst sharedRel = {along: 0, squaredDistance: 0};\r\n\r\n/**\r\n * @param {number} x The point x.\r\n * @param {number} y The point y.\r\n * @param {import(\"../coordinate.js\").Coordinate} start The segment start.\r\n * @param {import(\"../coordinate.js\").Coordinate} end The segment end.\r\n * @return {PointSegmentRelationship} The point segment relationship.  The returned object is\r\n * shared between calls and must not be modified by the caller.\r\n */\r\nfunction getPointSegmentRelationship(x, y, start, end) {\r\n  const x1 = start[0];\r\n  const y1 = start[1];\r\n  const x2 = end[0];\r\n  const y2 = end[1];\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  let along = 0;\r\n  let px = x1;\r\n  let py = y1;\r\n  if (dx !== 0 || dy !== 0) {\r\n    along = clamp(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);\r\n    px += dx * along;\r\n    py += dy * along;\r\n  }\r\n\r\n  sharedRel.along = along;\r\n  sharedRel.squaredDistance = toFixed(squaredDistance(x, y, px, py), 10);\r\n  return sharedRel;\r\n}\r\n\r\n/**\r\n * @param {LineCoordType} coordinates The coordinates.\r\n * @param {number} index The index.  May be fractional and may wrap.\r\n * @return {import(\"../coordinate.js\").Coordinate} The interpolated coordinate.\r\n */\r\nfunction interpolateCoordinate(coordinates, index) {\r\n  const count = coordinates.length;\r\n\r\n  let startIndex = Math.floor(index);\r\n  const along = index - startIndex;\r\n  if (startIndex >= count) {\r\n    startIndex -= count;\r\n  } else if (startIndex < 0) {\r\n    startIndex += count;\r\n  }\r\n\r\n  let endIndex = startIndex + 1;\r\n  if (endIndex >= count) {\r\n    endIndex -= count;\r\n  }\r\n\r\n  const start = coordinates[startIndex];\r\n  const x0 = start[0];\r\n  const y0 = start[1];\r\n  const end = coordinates[endIndex];\r\n  const dx = end[0] - x0;\r\n  const dy = end[1] - y0;\r\n\r\n  return [x0 + dx * along, y0 + dy * along];\r\n}\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\r\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\r\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Interaction for drawing feature geometries.\r\n *\r\n * @fires DrawEvent\r\n * @api\r\n */\r\nclass Draw extends PointerInteraction {\r\n  /**\r\n   * @param {Options} options Options.\r\n   */\r\n  constructor(options) {\r\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\r\n      options\r\n    );\r\n    if (!pointerOptions.stopDown) {\r\n      pointerOptions.stopDown = FALSE;\r\n    }\r\n\r\n    super(pointerOptions);\r\n\r\n    /***\r\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {DrawOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.shouldHandle_ = false;\r\n\r\n    /**\r\n     * @type {import(\"../pixel.js\").Pixel}\r\n     * @private\r\n     */\r\n    this.downPx_ = null;\r\n\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    this.downTimeout_;\r\n\r\n    /**\r\n     * @type {number|undefined}\r\n     * @private\r\n     */\r\n    this.lastDragTime_;\r\n\r\n    /**\r\n     * Pointer type of the last pointermove event\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this.pointerType_;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.freehand_ = false;\r\n\r\n    /**\r\n     * Target source for drawn features.\r\n     * @type {VectorSource|null}\r\n     * @private\r\n     */\r\n    this.source_ = options.source ? options.source : null;\r\n\r\n    /**\r\n     * Target collection for drawn features.\r\n     * @type {import(\"../Collection.js\").default<Feature>|null}\r\n     * @private\r\n     */\r\n    this.features_ = options.features ? options.features : null;\r\n\r\n    /**\r\n     * Pixel distance for snapping.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\r\n\r\n    /**\r\n     * Geometry type.\r\n     * @type {import(\"../geom/Geometry.js\").Type}\r\n     * @private\r\n     */\r\n    this.type_ = /** @type {import(\"../geom/Geometry.js\").Type} */ (\r\n      options.type\r\n    );\r\n\r\n    /**\r\n     * Drawing mode (derived from geometry type.\r\n     * @type {Mode}\r\n     * @private\r\n     */\r\n    this.mode_ = getMode(this.type_);\r\n\r\n    /**\r\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\r\n     * Default is `false`.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.stopClick_ = !!options.stopClick;\r\n\r\n    /**\r\n     * The number of points that must be drawn before a polygon ring or line\r\n     * string can be finished.  The default is 3 for polygon rings and 2 for\r\n     * line strings.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.minPoints_ = options.minPoints\r\n      ? options.minPoints\r\n      : this.mode_ === 'Polygon'\r\n      ? 3\r\n      : 2;\r\n\r\n    /**\r\n     * The number of points that can be drawn before a polygon ring or line string\r\n     * is finished. The default is no restriction.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.maxPoints_ =\r\n      this.mode_ === 'Circle'\r\n        ? 2\r\n        : options.maxPoints\r\n        ? options.maxPoints\r\n        : Infinity;\r\n\r\n    /**\r\n     * A function to decide if a potential finish coordinate is permissible\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\r\n    this.finishCondition_ = options.finishCondition\r\n      ? options.finishCondition\r\n      : TRUE;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\r\n     */\r\n    this.geometryLayout_ = options.geometryLayout\r\n      ? options.geometryLayout\r\n      : 'XY';\r\n\r\n    let geometryFunction = options.geometryFunction;\r\n    if (!geometryFunction) {\r\n      const mode = this.mode_;\r\n      if (mode === 'Circle') {\r\n        /**\r\n         * @param {!LineCoordType} coordinates The coordinates.\r\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\r\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\r\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\r\n         */\r\n        geometryFunction = function (coordinates, geometry, projection) {\r\n          const circle = geometry\r\n            ? /** @type {Circle} */ (geometry)\r\n            : new Circle([NaN, NaN]);\r\n          const center = fromUserCoordinate(coordinates[0], projection);\r\n          const squaredLength = squaredCoordinateDistance(\r\n            center,\r\n            fromUserCoordinate(coordinates[coordinates.length - 1], projection)\r\n          );\r\n          circle.setCenterAndRadius(\r\n            center,\r\n            Math.sqrt(squaredLength),\r\n            this.geometryLayout_\r\n          );\r\n          const userProjection = getUserProjection();\r\n          if (userProjection) {\r\n            circle.transform(projection, userProjection);\r\n          }\r\n          return circle;\r\n        };\r\n      } else {\r\n        let Constructor;\r\n        if (mode === 'Point') {\r\n          Constructor = Point;\r\n        } else if (mode === 'LineString') {\r\n          Constructor = LineString;\r\n        } else if (mode === 'Polygon') {\r\n          Constructor = Polygon;\r\n        }\r\n        /**\r\n         * @param {!LineCoordType} coordinates The coordinates.\r\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\r\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\r\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\r\n         */\r\n        geometryFunction = function (coordinates, geometry, projection) {\r\n          if (geometry) {\r\n            if (mode === 'Polygon') {\r\n              if (coordinates[0].length) {\r\n                // Add a closing coordinate to match the first\r\n                geometry.setCoordinates(\r\n                  [coordinates[0].concat([coordinates[0][0]])],\r\n                  this.geometryLayout_\r\n                );\r\n              } else {\r\n                geometry.setCoordinates([], this.geometryLayout_);\r\n              }\r\n            } else {\r\n              geometry.setCoordinates(coordinates, this.geometryLayout_);\r\n            }\r\n          } else {\r\n            geometry = new Constructor(coordinates, this.geometryLayout_);\r\n          }\r\n          return geometry;\r\n        };\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @type {GeometryFunction}\r\n     * @private\r\n     */\r\n    this.geometryFunction_ = geometryFunction;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.dragVertexDelay_ =\r\n      options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\r\n\r\n    /**\r\n     * Finish coordinate for the feature (first point for polygons, last point for\r\n     * linestrings).\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @private\r\n     */\r\n    this.finishCoordinate_ = null;\r\n\r\n    /**\r\n     * Sketch feature.\r\n     * @type {Feature<import('../geom/SimpleGeometry.js').default>}\r\n     * @private\r\n     */\r\n    this.sketchFeature_ = null;\r\n\r\n    /**\r\n     * Sketch point.\r\n     * @type {Feature<Point>}\r\n     * @private\r\n     */\r\n    this.sketchPoint_ = null;\r\n\r\n    /**\r\n     * Sketch coordinates. Used when drawing a line or polygon.\r\n     * @type {SketchCoordType}\r\n     * @private\r\n     */\r\n    this.sketchCoords_ = null;\r\n\r\n    /**\r\n     * Sketch line. Used when drawing polygon.\r\n     * @type {Feature<LineString>}\r\n     * @private\r\n     */\r\n    this.sketchLine_ = null;\r\n\r\n    /**\r\n     * Sketch line coordinates. Used when drawing a polygon or circle.\r\n     * @type {LineCoordType}\r\n     * @private\r\n     */\r\n    this.sketchLineCoords_ = null;\r\n\r\n    /**\r\n     * Squared tolerance for handling up events.  If the squared distance\r\n     * between a down and up event is greater than this tolerance, up events\r\n     * will not be handled.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.squaredClickTolerance_ = options.clickTolerance\r\n      ? options.clickTolerance * options.clickTolerance\r\n      : 36;\r\n\r\n    /**\r\n     * Draw overlay where our sketch features are drawn.\r\n     * @type {VectorLayer}\r\n     * @private\r\n     */\r\n    this.overlay_ = new VectorLayer({\r\n      source: new VectorSource({\r\n        useSpatialIndex: false,\r\n        wrapX: options.wrapX ? options.wrapX : false,\r\n      }),\r\n      style: options.style ? options.style : getDefaultStyleFunction(),\r\n      updateWhileInteracting: true,\r\n    });\r\n\r\n    /**\r\n     * Name of the geometry attribute for newly created features.\r\n     * @type {string|undefined}\r\n     * @private\r\n     */\r\n    this.geometryName_ = options.geometryName;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\r\n    this.condition_ = options.condition ? options.condition : noModifierKeys;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\r\n    this.freehandCondition_;\r\n    if (options.freehand) {\r\n      this.freehandCondition_ = always;\r\n    } else {\r\n      this.freehandCondition_ = options.freehandCondition\r\n        ? options.freehandCondition\r\n        : shiftKeyOnly;\r\n    }\r\n\r\n    /**\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     * @private\r\n     */\r\n    this.traceCondition_;\r\n    this.setTrace(options.trace || false);\r\n\r\n    /**\r\n     * @type {TraceState}\r\n     * @private\r\n     */\r\n    this.traceState_ = {active: false};\r\n\r\n    /**\r\n     * @type {VectorSource|null}\r\n     * @private\r\n     */\r\n    this.traceSource_ = options.traceSource || options.source || null;\r\n\r\n    this.addChangeListener(InteractionProperty.ACTIVE, this.updateState_);\r\n  }\r\n\r\n  /**\r\n   * Toggle tracing mode or set a tracing condition.\r\n   *\r\n   * @param {boolean|import(\"../events/condition.js\").Condition} trace A boolean to toggle tracing mode or an event\r\n   *     condition that will be checked when a feature is clicked to determine if tracing should be active.\r\n   */\r\n  setTrace(trace) {\r\n    let condition;\r\n    if (!trace) {\r\n      condition = never;\r\n    } else if (trace === true) {\r\n      condition = always;\r\n    } else {\r\n      condition = trace;\r\n    }\r\n    this.traceCondition_ = condition;\r\n  }\r\n\r\n  /**\r\n   * Remove the interaction from its current map and attach it to the new map.\r\n   * Subclasses may set up event handlers to get notified about changes to\r\n   * the map here.\r\n   * @param {import(\"../Map.js\").default} map Map.\r\n   */\r\n  setMap(map) {\r\n    super.setMap(map);\r\n    this.updateState_();\r\n  }\r\n\r\n  /**\r\n   * Get the overlay layer that this interaction renders sketch features to.\r\n   * @return {VectorLayer} Overlay layer.\r\n   * @api\r\n   */\r\n  getOverlay() {\r\n    return this.overlay_;\r\n  }\r\n\r\n  /**\r\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\r\n   * @return {boolean} `false` to stop event propagation.\r\n   * @api\r\n   */\r\n  handleEvent(event) {\r\n    if (event.originalEvent.type === EventType.CONTEXTMENU) {\r\n      // Avoid context menu for long taps when drawing on mobile\r\n      event.originalEvent.preventDefault();\r\n    }\r\n    this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);\r\n    let move = event.type === MapBrowserEventType.POINTERMOVE;\r\n    let pass = true;\r\n    if (\r\n      !this.freehand_ &&\r\n      this.lastDragTime_ &&\r\n      event.type === MapBrowserEventType.POINTERDRAG\r\n    ) {\r\n      const now = Date.now();\r\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\r\n        this.downPx_ = event.pixel;\r\n        this.shouldHandle_ = !this.freehand_;\r\n        move = true;\r\n      } else {\r\n        this.lastDragTime_ = undefined;\r\n      }\r\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\r\n        clearTimeout(this.downTimeout_);\r\n        this.downTimeout_ = undefined;\r\n      }\r\n    }\r\n    if (\r\n      this.freehand_ &&\r\n      event.type === MapBrowserEventType.POINTERDRAG &&\r\n      this.sketchFeature_ !== null\r\n    ) {\r\n      this.addToDrawing_(event.coordinate);\r\n      pass = false;\r\n    } else if (\r\n      this.freehand_ &&\r\n      event.type === MapBrowserEventType.POINTERDOWN\r\n    ) {\r\n      pass = false;\r\n    } else if (move && this.getPointerCount() < 2) {\r\n      pass = event.type === MapBrowserEventType.POINTERMOVE;\r\n      if (pass && this.freehand_) {\r\n        this.handlePointerMove_(event);\r\n        if (this.shouldHandle_) {\r\n          // Avoid page scrolling when freehand drawing on mobile\r\n          event.originalEvent.preventDefault();\r\n        }\r\n      } else if (\r\n        event.originalEvent.pointerType === 'mouse' ||\r\n        (event.type === MapBrowserEventType.POINTERDRAG &&\r\n          this.downTimeout_ === undefined)\r\n      ) {\r\n        this.handlePointerMove_(event);\r\n      }\r\n    } else if (event.type === MapBrowserEventType.DBLCLICK) {\r\n      pass = false;\r\n    }\r\n\r\n    return super.handleEvent(event) && pass;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleDownEvent(event) {\r\n    this.shouldHandle_ = !this.freehand_;\r\n\r\n    if (this.freehand_) {\r\n      this.downPx_ = event.pixel;\r\n      if (!this.finishCoordinate_) {\r\n        this.startDrawing_(event.coordinate);\r\n      }\r\n      return true;\r\n    }\r\n\r\n    if (!this.condition_(event)) {\r\n      this.lastDragTime_ = undefined;\r\n      return false;\r\n    }\r\n\r\n    this.lastDragTime_ = Date.now();\r\n    this.downTimeout_ = setTimeout(() => {\r\n      this.handlePointerMove_(\r\n        new MapBrowserEvent(\r\n          MapBrowserEventType.POINTERMOVE,\r\n          event.map,\r\n          event.originalEvent,\r\n          false,\r\n          event.frameState\r\n        )\r\n      );\r\n    }, this.dragVertexDelay_);\r\n    this.downPx_ = event.pixel;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  deactivateTrace_() {\r\n    this.traceState_ = {active: false};\r\n  }\r\n\r\n  /**\r\n   * Activate or deactivate trace state based on a browser event.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @private\r\n   */\r\n  toggleTraceState_(event) {\r\n    if (!this.traceSource_ || !this.traceCondition_(event)) {\r\n      return;\r\n    }\r\n\r\n    if (this.traceState_.active) {\r\n      this.deactivateTrace_();\r\n      return;\r\n    }\r\n\r\n    const map = this.getMap();\r\n    const lowerLeft = map.getCoordinateFromPixel([\r\n      event.pixel[0] - this.snapTolerance_,\r\n      event.pixel[1] + this.snapTolerance_,\r\n    ]);\r\n    const upperRight = map.getCoordinateFromPixel([\r\n      event.pixel[0] + this.snapTolerance_,\r\n      event.pixel[1] - this.snapTolerance_,\r\n    ]);\r\n    const extent = boundingExtent([lowerLeft, upperRight]);\r\n    const features = this.traceSource_.getFeaturesInExtent(extent);\r\n    if (features.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const targets = getTraceTargets(event.coordinate, features);\r\n    if (targets.length) {\r\n      this.traceState_ = {\r\n        active: true,\r\n        startPx: event.pixel.slice(),\r\n        targets: targets,\r\n        targetIndex: -1,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {TraceTarget} target The trace target.\r\n   * @param {number} endIndex The new end index of the trace.\r\n   * @private\r\n   */\r\n  addOrRemoveTracedCoordinates_(target, endIndex) {\r\n    // three cases to handle:\r\n    //  1. traced in the same direction and points need adding\r\n    //  2. traced in the same direction and points need removing\r\n    //  3. traced in a new direction\r\n    const previouslyForward = target.startIndex <= target.endIndex;\r\n    const currentlyForward = target.startIndex <= endIndex;\r\n    if (previouslyForward === currentlyForward) {\r\n      // same direction\r\n      if (\r\n        (previouslyForward && endIndex > target.endIndex) ||\r\n        (!previouslyForward && endIndex < target.endIndex)\r\n      ) {\r\n        // case 1 - add new points\r\n        this.addTracedCoordinates_(target, target.endIndex, endIndex);\r\n      } else if (\r\n        (previouslyForward && endIndex < target.endIndex) ||\r\n        (!previouslyForward && endIndex > target.endIndex)\r\n      ) {\r\n        // case 2 - remove old points\r\n        this.removeTracedCoordinates_(endIndex, target.endIndex);\r\n      }\r\n    } else {\r\n      // case 3 - remove old points, add new points\r\n      this.removeTracedCoordinates_(target.startIndex, target.endIndex);\r\n      this.addTracedCoordinates_(target, target.startIndex, endIndex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} fromIndex The start index.\r\n   * @param {number} toIndex The end index.\r\n   * @private\r\n   */\r\n  removeTracedCoordinates_(fromIndex, toIndex) {\r\n    if (fromIndex === toIndex) {\r\n      return;\r\n    }\r\n\r\n    let remove = 0;\r\n    if (fromIndex < toIndex) {\r\n      const start = Math.ceil(fromIndex);\r\n      let end = Math.floor(toIndex);\r\n      if (end === toIndex) {\r\n        end -= 1;\r\n      }\r\n      remove = end - start + 1;\r\n    } else {\r\n      const start = Math.floor(fromIndex);\r\n      let end = Math.ceil(toIndex);\r\n      if (end === toIndex) {\r\n        end += 1;\r\n      }\r\n      remove = start - end + 1;\r\n    }\r\n\r\n    if (remove > 0) {\r\n      this.removeLastPoints_(remove);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {TraceTarget} target The trace target.\r\n   * @param {number} fromIndex The start index.\r\n   * @param {number} toIndex The end index.\r\n   * @private\r\n   */\r\n  addTracedCoordinates_(target, fromIndex, toIndex) {\r\n    if (fromIndex === toIndex) {\r\n      return;\r\n    }\r\n\r\n    const coordinates = [];\r\n    if (fromIndex < toIndex) {\r\n      // forward trace\r\n      const start = Math.ceil(fromIndex);\r\n      let end = Math.floor(toIndex);\r\n      if (end === toIndex) {\r\n        // if end is snapped to a vertex, it will be added later\r\n        end -= 1;\r\n      }\r\n      for (let i = start; i <= end; ++i) {\r\n        coordinates.push(getCoordinate(target.coordinates, i));\r\n      }\r\n    } else {\r\n      // reverse trace\r\n      const start = Math.floor(fromIndex);\r\n      let end = Math.ceil(toIndex);\r\n      if (end === toIndex) {\r\n        end += 1;\r\n      }\r\n      for (let i = start; i >= end; --i) {\r\n        coordinates.push(getCoordinate(target.coordinates, i));\r\n      }\r\n    }\r\n    if (coordinates.length) {\r\n      this.appendCoordinates(coordinates);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the trace.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @private\r\n   */\r\n  updateTrace_(event) {\r\n    const traceState = this.traceState_;\r\n    if (!traceState.active) {\r\n      return;\r\n    }\r\n\r\n    if (traceState.targetIndex === -1) {\r\n      // check if we are ready to pick a target\r\n      if (distance(traceState.startPx, event.pixel) < this.snapTolerance_) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    const updatedTraceTarget = getTraceTargetUpdate(\r\n      event.coordinate,\r\n      traceState,\r\n      this.getMap(),\r\n      this.snapTolerance_\r\n    );\r\n\r\n    if (traceState.targetIndex !== updatedTraceTarget.index) {\r\n      // target changed\r\n      if (traceState.targetIndex !== -1) {\r\n        // remove points added during previous trace\r\n        const oldTarget = traceState.targets[traceState.targetIndex];\r\n        this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);\r\n      }\r\n      // add points for the new target\r\n      const newTarget = traceState.targets[updatedTraceTarget.index];\r\n      this.addTracedCoordinates_(\r\n        newTarget,\r\n        newTarget.startIndex,\r\n        updatedTraceTarget.endIndex\r\n      );\r\n    } else {\r\n      // target stayed the same\r\n      const target = traceState.targets[traceState.targetIndex];\r\n      this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);\r\n    }\r\n\r\n    // modify the state with updated info\r\n    traceState.targetIndex = updatedTraceTarget.index;\r\n    const target = traceState.targets[traceState.targetIndex];\r\n    target.endIndex = updatedTraceTarget.endIndex;\r\n\r\n    // update event coordinate and pixel to match end point of final segment\r\n    const coordinate = interpolateCoordinate(\r\n      target.coordinates,\r\n      target.endIndex\r\n    );\r\n    const pixel = this.getMap().getPixelFromCoordinate(coordinate);\r\n    event.coordinate = coordinate;\r\n    event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];\r\n  }\r\n\r\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleUpEvent(event) {\r\n    let pass = true;\r\n\r\n    if (this.getPointerCount() === 0) {\r\n      if (this.downTimeout_) {\r\n        clearTimeout(this.downTimeout_);\r\n        this.downTimeout_ = undefined;\r\n      }\r\n\r\n      this.handlePointerMove_(event);\r\n      const tracing = this.traceState_.active;\r\n      this.toggleTraceState_(event);\r\n\r\n      if (this.shouldHandle_) {\r\n        const startingToDraw = !this.finishCoordinate_;\r\n        if (startingToDraw) {\r\n          this.startDrawing_(event.coordinate);\r\n        }\r\n        if (!startingToDraw && this.freehand_) {\r\n          this.finishDrawing();\r\n        } else if (\r\n          !this.freehand_ &&\r\n          (!startingToDraw || this.mode_ === 'Point')\r\n        ) {\r\n          if (this.atFinish_(event.pixel, tracing)) {\r\n            if (this.finishCondition_(event)) {\r\n              this.finishDrawing();\r\n            }\r\n          } else {\r\n            this.addToDrawing_(event.coordinate);\r\n          }\r\n        }\r\n        pass = false;\r\n      } else if (this.freehand_) {\r\n        this.abortDrawing();\r\n      }\r\n    }\r\n\r\n    if (!pass && this.stopClick_) {\r\n      event.preventDefault();\r\n    }\r\n    return pass;\r\n  }\r\n\r\n  /**\r\n   * Handle move events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\r\n   * @private\r\n   */\r\n  handlePointerMove_(event) {\r\n    this.pointerType_ = event.originalEvent.pointerType;\r\n    if (\r\n      this.downPx_ &&\r\n      ((!this.freehand_ && this.shouldHandle_) ||\r\n        (this.freehand_ && !this.shouldHandle_))\r\n    ) {\r\n      const downPx = this.downPx_;\r\n      const clickPx = event.pixel;\r\n      const dx = downPx[0] - clickPx[0];\r\n      const dy = downPx[1] - clickPx[1];\r\n      const squaredDistance = dx * dx + dy * dy;\r\n      this.shouldHandle_ = this.freehand_\r\n        ? squaredDistance > this.squaredClickTolerance_\r\n        : squaredDistance <= this.squaredClickTolerance_;\r\n      if (!this.shouldHandle_) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (!this.finishCoordinate_) {\r\n      this.createOrUpdateSketchPoint_(event.coordinate.slice());\r\n      return;\r\n    }\r\n\r\n    this.updateTrace_(event);\r\n    this.modifyDrawing_(event.coordinate);\r\n  }\r\n\r\n  /**\r\n   * Determine if an event is within the snapping tolerance of the start coord.\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\r\n   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).\r\n   * @return {boolean} The event is within the snapping tolerance of the start.\r\n   * @private\r\n   */\r\n  atFinish_(pixel, tracing) {\r\n    let at = false;\r\n    if (this.sketchFeature_) {\r\n      let potentiallyDone = false;\r\n      let potentiallyFinishCoordinates = [this.finishCoordinate_];\r\n      const mode = this.mode_;\r\n      if (mode === 'Point') {\r\n        at = true;\r\n      } else if (mode === 'Circle') {\r\n        at = this.sketchCoords_.length === 2;\r\n      } else if (mode === 'LineString') {\r\n        potentiallyDone =\r\n          !tracing && this.sketchCoords_.length > this.minPoints_;\r\n      } else if (mode === 'Polygon') {\r\n        const sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\r\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\r\n        potentiallyFinishCoordinates = [\r\n          sketchCoords[0][0],\r\n          sketchCoords[0][sketchCoords[0].length - 2],\r\n        ];\r\n        if (tracing) {\r\n          potentiallyFinishCoordinates = [sketchCoords[0][0]];\r\n        } else {\r\n          potentiallyFinishCoordinates = [\r\n            sketchCoords[0][0],\r\n            sketchCoords[0][sketchCoords[0].length - 2],\r\n          ];\r\n        }\r\n      }\r\n      if (potentiallyDone) {\r\n        const map = this.getMap();\r\n        for (let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\r\n          const finishCoordinate = potentiallyFinishCoordinates[i];\r\n          const finishPixel = map.getPixelFromCoordinate(finishCoordinate);\r\n          const dx = pixel[0] - finishPixel[0];\r\n          const dy = pixel[1] - finishPixel[1];\r\n          const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\r\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\r\n          if (at) {\r\n            this.finishCoordinate_ = finishCoordinate;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return at;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\r\n   * @private\r\n   */\r\n  createOrUpdateSketchPoint_(coordinates) {\r\n    if (!this.sketchPoint_) {\r\n      this.sketchPoint_ = new Feature(new Point(coordinates));\r\n      this.updateSketchFeatures_();\r\n    } else {\r\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\r\n      sketchPointGeom.setCoordinates(coordinates);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\r\n   * @private\r\n   */\r\n  createOrUpdateCustomSketchLine_(geometry) {\r\n    if (!this.sketchLine_) {\r\n      this.sketchLine_ = new Feature();\r\n    }\r\n    const ring = geometry.getLinearRing(0);\r\n    let sketchLineGeom = this.sketchLine_.getGeometry();\r\n    if (!sketchLineGeom) {\r\n      sketchLineGeom = new LineString(\r\n        ring.getFlatCoordinates(),\r\n        ring.getLayout()\r\n      );\r\n      this.sketchLine_.setGeometry(sketchLineGeom);\r\n    } else {\r\n      sketchLineGeom.setFlatCoordinates(\r\n        ring.getLayout(),\r\n        ring.getFlatCoordinates()\r\n      );\r\n      sketchLineGeom.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start the drawing.\r\n   * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\r\n   * @private\r\n   */\r\n  startDrawing_(start) {\r\n    const projection = this.getMap().getView().getProjection();\r\n    const stride = getStrideForLayout(this.geometryLayout_);\r\n    while (start.length < stride) {\r\n      start.push(0);\r\n    }\r\n    this.finishCoordinate_ = start;\r\n    if (this.mode_ === 'Point') {\r\n      this.sketchCoords_ = start.slice();\r\n    } else if (this.mode_ === 'Polygon') {\r\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\r\n      this.sketchLineCoords_ = this.sketchCoords_[0];\r\n    } else {\r\n      this.sketchCoords_ = [start.slice(), start.slice()];\r\n    }\r\n    if (this.sketchLineCoords_) {\r\n      this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\r\n    }\r\n    const geometry = this.geometryFunction_(\r\n      this.sketchCoords_,\r\n      undefined,\r\n      projection\r\n    );\r\n    this.sketchFeature_ = new Feature();\r\n    if (this.geometryName_) {\r\n      this.sketchFeature_.setGeometryName(this.geometryName_);\r\n    }\r\n    this.sketchFeature_.setGeometry(geometry);\r\n    this.updateSketchFeatures_();\r\n    this.dispatchEvent(\r\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Modify the drawing.\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @private\r\n   */\r\n  modifyDrawing_(coordinate) {\r\n    const map = this.getMap();\r\n    const geometry = this.sketchFeature_.getGeometry();\r\n    const projection = map.getView().getProjection();\r\n    const stride = getStrideForLayout(this.geometryLayout_);\r\n    let coordinates, last;\r\n    while (coordinate.length < stride) {\r\n      coordinate.push(0);\r\n    }\r\n    if (this.mode_ === 'Point') {\r\n      last = this.sketchCoords_;\r\n    } else if (this.mode_ === 'Polygon') {\r\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\r\n      last = coordinates[coordinates.length - 1];\r\n      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\r\n        // snap to finish\r\n        coordinate = this.finishCoordinate_.slice();\r\n      }\r\n    } else {\r\n      coordinates = this.sketchCoords_;\r\n      last = coordinates[coordinates.length - 1];\r\n    }\r\n    last[0] = coordinate[0];\r\n    last[1] = coordinate[1];\r\n    this.geometryFunction_(\r\n      /** @type {!LineCoordType} */ (this.sketchCoords_),\r\n      geometry,\r\n      projection\r\n    );\r\n    if (this.sketchPoint_) {\r\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\r\n      sketchPointGeom.setCoordinates(coordinate);\r\n    }\r\n    if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {\r\n      this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\r\n    } else if (this.sketchLineCoords_) {\r\n      const sketchLineGeom = this.sketchLine_.getGeometry();\r\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\r\n    }\r\n    this.updateSketchFeatures_();\r\n  }\r\n\r\n  /**\r\n   * Add a new coordinate to the drawing.\r\n   * @param {!PointCoordType} coordinate Coordinate\r\n   * @private\r\n   */\r\n  addToDrawing_(coordinate) {\r\n    const geometry = this.sketchFeature_.getGeometry();\r\n    const projection = this.getMap().getView().getProjection();\r\n    let done;\r\n    let coordinates;\r\n    const mode = this.mode_;\r\n    if (mode === 'LineString' || mode === 'Circle') {\r\n      this.finishCoordinate_ = coordinate.slice();\r\n      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\r\n      if (coordinates.length >= this.maxPoints_) {\r\n        if (this.freehand_) {\r\n          coordinates.pop();\r\n        } else {\r\n          done = true;\r\n        }\r\n      }\r\n      coordinates.push(coordinate.slice());\r\n      this.geometryFunction_(coordinates, geometry, projection);\r\n    } else if (mode === 'Polygon') {\r\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\r\n      if (coordinates.length >= this.maxPoints_) {\r\n        if (this.freehand_) {\r\n          coordinates.pop();\r\n        } else {\r\n          done = true;\r\n        }\r\n      }\r\n      coordinates.push(coordinate.slice());\r\n      if (done) {\r\n        this.finishCoordinate_ = coordinates[0];\r\n      }\r\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\r\n    }\r\n    this.createOrUpdateSketchPoint_(coordinate.slice());\r\n    this.updateSketchFeatures_();\r\n    if (done) {\r\n      this.finishDrawing();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} n The number of points to remove.\r\n   */\r\n  removeLastPoints_(n) {\r\n    if (!this.sketchFeature_) {\r\n      return;\r\n    }\r\n    const geometry = this.sketchFeature_.getGeometry();\r\n    const projection = this.getMap().getView().getProjection();\r\n    const mode = this.mode_;\r\n    for (let i = 0; i < n; ++i) {\r\n      let coordinates;\r\n      if (mode === 'LineString' || mode === 'Circle') {\r\n        coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\r\n        coordinates.splice(-2, 1);\r\n        if (coordinates.length >= 2) {\r\n          this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\r\n          const finishCoordinate = this.finishCoordinate_.slice();\r\n          coordinates[coordinates.length - 1] = finishCoordinate;\r\n          this.createOrUpdateSketchPoint_(finishCoordinate);\r\n        }\r\n        this.geometryFunction_(coordinates, geometry, projection);\r\n        if (geometry.getType() === 'Polygon' && this.sketchLine_) {\r\n          this.createOrUpdateCustomSketchLine_(\r\n            /** @type {Polygon} */ (geometry)\r\n          );\r\n        }\r\n      } else if (mode === 'Polygon') {\r\n        coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\r\n        coordinates.splice(-2, 1);\r\n        const sketchLineGeom = this.sketchLine_.getGeometry();\r\n        if (coordinates.length >= 2) {\r\n          const finishCoordinate = coordinates[coordinates.length - 2].slice();\r\n          coordinates[coordinates.length - 1] = finishCoordinate;\r\n          this.createOrUpdateSketchPoint_(finishCoordinate);\r\n        }\r\n        sketchLineGeom.setCoordinates(coordinates);\r\n        this.geometryFunction_(this.sketchCoords_, geometry, projection);\r\n      }\r\n\r\n      if (coordinates.length === 1) {\r\n        this.abortDrawing();\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.updateSketchFeatures_();\r\n  }\r\n\r\n  /**\r\n   * Remove last point of the feature currently being drawn. Does not do anything when\r\n   * drawing POINT or MULTI_POINT geometries.\r\n   * @api\r\n   */\r\n  removeLastPoint() {\r\n    this.removeLastPoints_(1);\r\n  }\r\n\r\n  /**\r\n   * Stop drawing and add the sketch feature to the target layer.\r\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\r\n   * dispatched before inserting the feature.\r\n   * @api\r\n   */\r\n  finishDrawing() {\r\n    const sketchFeature = this.abortDrawing_();\r\n    if (!sketchFeature) {\r\n      return;\r\n    }\r\n    let coordinates = this.sketchCoords_;\r\n    const geometry = sketchFeature.getGeometry();\r\n    const projection = this.getMap().getView().getProjection();\r\n    if (this.mode_ === 'LineString') {\r\n      // remove the redundant last point\r\n      coordinates.pop();\r\n      this.geometryFunction_(coordinates, geometry, projection);\r\n    } else if (this.mode_ === 'Polygon') {\r\n      // remove the redundant last point in ring\r\n      /** @type {PolyCoordType} */ (coordinates)[0].pop();\r\n      this.geometryFunction_(coordinates, geometry, projection);\r\n      coordinates = geometry.getCoordinates();\r\n    }\r\n\r\n    // cast multi-part geometries\r\n    if (this.type_ === 'MultiPoint') {\r\n      sketchFeature.setGeometry(\r\n        new MultiPoint([/** @type {PointCoordType} */ (coordinates)])\r\n      );\r\n    } else if (this.type_ === 'MultiLineString') {\r\n      sketchFeature.setGeometry(\r\n        new MultiLineString([/** @type {LineCoordType} */ (coordinates)])\r\n      );\r\n    } else if (this.type_ === 'MultiPolygon') {\r\n      sketchFeature.setGeometry(\r\n        new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)])\r\n      );\r\n    }\r\n\r\n    // First dispatch event to allow full set up of feature\r\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\r\n\r\n    // Then insert feature\r\n    if (this.features_) {\r\n      this.features_.push(sketchFeature);\r\n    }\r\n    if (this.source_) {\r\n      this.source_.addFeature(sketchFeature);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop drawing without adding the sketch feature to the target layer.\r\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\r\n   * @private\r\n   */\r\n  abortDrawing_() {\r\n    this.finishCoordinate_ = null;\r\n    const sketchFeature = this.sketchFeature_;\r\n    this.sketchFeature_ = null;\r\n    this.sketchPoint_ = null;\r\n    this.sketchLine_ = null;\r\n    this.overlay_.getSource().clear(true);\r\n    this.deactivateTrace_();\r\n    return sketchFeature;\r\n  }\r\n\r\n  /**\r\n   * Stop drawing without adding the sketch feature to the target layer.\r\n   * @api\r\n   */\r\n  abortDrawing() {\r\n    const sketchFeature = this.abortDrawing_();\r\n    if (sketchFeature) {\r\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append coordinates to the end of the geometry that is currently being drawn.\r\n   * This can be used when drawing LineStrings or Polygons. Coordinates will\r\n   * either be appended to the current LineString or the outer ring of the current\r\n   * Polygon. If no geometry is being drawn, a new one will be created.\r\n   * @param {!LineCoordType} coordinates Linear coordinates to be appended to\r\n   * the coordinate array.\r\n   * @api\r\n   */\r\n  appendCoordinates(coordinates) {\r\n    const mode = this.mode_;\r\n    const newDrawing = !this.sketchFeature_;\r\n    if (newDrawing) {\r\n      this.startDrawing_(coordinates[0]);\r\n    }\r\n    /** @type {LineCoordType} */\r\n    let sketchCoords;\r\n    if (mode === 'LineString' || mode === 'Circle') {\r\n      sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);\r\n    } else if (mode === 'Polygon') {\r\n      sketchCoords =\r\n        this.sketchCoords_ && this.sketchCoords_.length\r\n          ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]\r\n          : [];\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    if (newDrawing) {\r\n      sketchCoords.shift();\r\n    }\r\n\r\n    // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\r\n    sketchCoords.pop();\r\n\r\n    // Append coordinate list\r\n    for (let i = 0; i < coordinates.length; i++) {\r\n      this.addToDrawing_(coordinates[i]);\r\n    }\r\n\r\n    const ending = coordinates[coordinates.length - 1];\r\n    // Duplicate last coordinate for sketch drawing (cursor position)\r\n    this.addToDrawing_(ending);\r\n    this.modifyDrawing_(ending);\r\n  }\r\n\r\n  /**\r\n   * Initiate draw mode by starting from an existing geometry which will\r\n   * receive new additional points. This only works on features with\r\n   * `LineString` geometries, where the interaction will extend lines by adding\r\n   * points to the end of the coordinates array.\r\n   * This will change the original feature, instead of drawing a copy.\r\n   *\r\n   * The function will dispatch a `drawstart` event.\r\n   *\r\n   * @param {!Feature<LineString>} feature Feature to be extended.\r\n   * @api\r\n   */\r\n  extend(feature) {\r\n    const geometry = feature.getGeometry();\r\n    const lineString = geometry;\r\n    this.sketchFeature_ = feature;\r\n    this.sketchCoords_ = lineString.getCoordinates();\r\n    const last = this.sketchCoords_[this.sketchCoords_.length - 1];\r\n    this.finishCoordinate_ = last.slice();\r\n    this.sketchCoords_.push(last.slice());\r\n    this.sketchPoint_ = new Feature(new Point(last));\r\n    this.updateSketchFeatures_();\r\n    this.dispatchEvent(\r\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Redraw the sketch features.\r\n   * @private\r\n   */\r\n  updateSketchFeatures_() {\r\n    const sketchFeatures = [];\r\n    if (this.sketchFeature_) {\r\n      sketchFeatures.push(this.sketchFeature_);\r\n    }\r\n    if (this.sketchLine_) {\r\n      sketchFeatures.push(this.sketchLine_);\r\n    }\r\n    if (this.sketchPoint_) {\r\n      sketchFeatures.push(this.sketchPoint_);\r\n    }\r\n    const overlaySource = this.overlay_.getSource();\r\n    overlaySource.clear(true);\r\n    overlaySource.addFeatures(sketchFeatures);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  updateState_() {\r\n    const map = this.getMap();\r\n    const active = this.getActive();\r\n    if (!map || !active) {\r\n      this.abortDrawing();\r\n    }\r\n    this.overlay_.setMap(active ? map : null);\r\n  }\r\n}\r\n\r\n/**\r\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\r\n */\r\nfunction getDefaultStyleFunction() {\r\n  const styles = createEditingStyle();\r\n  return function (feature, resolution) {\r\n    return styles[feature.getGeometry().getType()];\r\n  };\r\n}\r\n\r\n/**\r\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\r\n * polygon with a user specified number of sides and start angle instead of a\r\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\r\n * @param {number} [sides] Number of sides of the regular polygon.\r\n *     Default is 32.\r\n * @param {number} [angle] Angle of the first point in counter-clockwise\r\n *     radians. 0 means East.\r\n *     Default is the angle defined by the heading from the center of the\r\n *     regular polygon to the current pointer position.\r\n * @return {GeometryFunction} Function that draws a polygon.\r\n * @api\r\n */\r\nexport function createRegularPolygon(sides, angle) {\r\n  return function (coordinates, geometry, projection) {\r\n    const center = fromUserCoordinate(\r\n      /** @type {LineCoordType} */ (coordinates)[0],\r\n      projection\r\n    );\r\n    const end = fromUserCoordinate(\r\n      /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1],\r\n      projection\r\n    );\r\n    const radius = Math.sqrt(squaredCoordinateDistance(center, end));\r\n    geometry = geometry || fromCircle(new Circle(center), sides);\r\n\r\n    let internalAngle = angle;\r\n    if (!angle && angle !== 0) {\r\n      const x = end[0] - center[0];\r\n      const y = end[1] - center[1];\r\n      internalAngle = Math.atan2(y, x);\r\n    }\r\n    makeRegular(\r\n      /** @type {Polygon} */ (geometry),\r\n      center,\r\n      radius,\r\n      internalAngle\r\n    );\r\n\r\n    const userProjection = getUserProjection();\r\n    if (userProjection) {\r\n      geometry.transform(projection, userProjection);\r\n    }\r\n    return geometry;\r\n  };\r\n}\r\n\r\n/**\r\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\r\n * with the coordinate system axes).  Use this with the draw interaction and\r\n * `type: 'Circle'` to return a box instead of a circle geometry.\r\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\r\n * @api\r\n */\r\nexport function createBox() {\r\n  return function (coordinates, geometry, projection) {\r\n    const extent = boundingExtent(\r\n      /** @type {LineCoordType} */ ([\r\n        coordinates[0],\r\n        coordinates[coordinates.length - 1],\r\n      ]).map(function (coordinate) {\r\n        return fromUserCoordinate(coordinate, projection);\r\n      })\r\n    );\r\n    const boxCoordinates = [\r\n      [\r\n        getBottomLeft(extent),\r\n        getBottomRight(extent),\r\n        getTopRight(extent),\r\n        getTopLeft(extent),\r\n        getBottomLeft(extent),\r\n      ],\r\n    ];\r\n    if (geometry) {\r\n      geometry.setCoordinates(boxCoordinates);\r\n    } else {\r\n      geometry = new Polygon(boxCoordinates);\r\n    }\r\n    const userProjection = getUserProjection();\r\n    if (userProjection) {\r\n      geometry.transform(projection, userProjection);\r\n    }\r\n    return geometry;\r\n  };\r\n}\r\n\r\n/**\r\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\r\n * their single-part cousins.\r\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\r\n * @return {Mode} Drawing mode.\r\n */\r\nfunction getMode(type) {\r\n  switch (type) {\r\n    case 'Point':\r\n    case 'MultiPoint':\r\n      return 'Point';\r\n    case 'LineString':\r\n    case 'MultiLineString':\r\n      return 'LineString';\r\n    case 'Polygon':\r\n    case 'MultiPolygon':\r\n      return 'Polygon';\r\n    case 'Circle':\r\n      return 'Circle';\r\n    default:\r\n      throw new Error('Invalid type: ' + type);\r\n  }\r\n}\r\n\r\nexport default Draw;\r\n", "/**\r\n * @module ol/interaction/Extent\r\n */\r\nimport Event from '../events/Event.js';\r\nimport Feature from '../Feature.js';\r\nimport MapBrowserEventType from '../MapBrowserEventType.js';\r\nimport Point from '../geom/Point.js';\r\nimport PointerInteraction from './Pointer.js';\r\nimport VectorLayer from '../layer/Vector.js';\r\nimport VectorSource from '../source/Vector.js';\r\nimport {always} from '../events/condition.js';\r\nimport {boundingExtent, getArea} from '../extent.js';\r\nimport {\r\n  closestOnSegment,\r\n  distance as coordinateDistance,\r\n  squaredDistance as squaredCoordinateDistance,\r\n  squaredDistanceToSegment,\r\n} from '../coordinate.js';\r\nimport {createEditingStyle} from '../style/Style.js';\r\nimport {fromExtent as polygonFromExtent} from '../geom/Polygon.js';\r\nimport {toUserExtent} from '../proj.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\r\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event should be handled.\r\n * Default is {@link module:ol/events/condition.always}.\r\n * @property {import(\"../extent.js\").Extent} [extent] Initial extent. Defaults to no\r\n * initial extent.\r\n * @property {import(\"../style/Style.js\").StyleLike} [boxStyle]\r\n * Style for the drawn extent box. Defaults to the `Polygon` editing style\r\n * documented in {@link module:ol/style/Style~Style}\r\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the\r\n * pointer close enough to a segment or vertex for editing.\r\n * @property {import(\"../style/Style.js\").StyleLike} [pointerStyle]\r\n * Style for the cursor used to draw the extent. Defaults to the `Point` editing style\r\n * documented in {@link module:ol/style/Style~Style}\r\n * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps\r\n * in the X direction? Only affects visuals, not functionality.\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nconst ExtentEventType = {\r\n  /**\r\n   * Triggered after the extent is changed\r\n   * @event ExtentEvent#extentchanged\r\n   * @api\r\n   */\r\n  EXTENTCHANGED: 'extentchanged',\r\n};\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/interaction/Extent~Extent} instances are\r\n * instances of this type.\r\n */\r\nexport class ExtentEvent extends Event {\r\n  /**\r\n   * @param {import(\"../extent.js\").Extent} extent the new extent\r\n   */\r\n  constructor(extent) {\r\n    super(ExtentEventType.EXTENTCHANGED);\r\n\r\n    /**\r\n     * The current extent.\r\n     * @type {import(\"../extent.js\").Extent}\r\n     * @api\r\n     */\r\n    this.extent = extent;\r\n  }\r\n}\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\r\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<'extentchanged', ExtentEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\r\n *     'change:active'|'extentchanged', Return>} ExtentOnSignature\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Allows the user to draw a vector box by clicking and dragging on the map.\r\n * Once drawn, the vector box can be modified by dragging its vertices or edges.\r\n * This interaction is only supported for mouse devices.\r\n *\r\n * @fires ExtentEvent\r\n * @api\r\n */\r\nclass Extent extends PointerInteraction {\r\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\r\n  constructor(options) {\r\n    options = options || {};\r\n\r\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\r\n\r\n    /***\r\n     * @type {ExtentOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {ExtentOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {ExtentOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * Condition\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     * @private\r\n     */\r\n    this.condition_ = options.condition ? options.condition : always;\r\n\r\n    /**\r\n     * Extent of the drawn box\r\n     * @type {import(\"../extent.js\").Extent}\r\n     * @private\r\n     */\r\n    this.extent_ = null;\r\n\r\n    /**\r\n     * Handler for pointer move events\r\n     * @type {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent|null}\r\n     * @private\r\n     */\r\n    this.pointerHandler_ = null;\r\n\r\n    /**\r\n     * Pixel threshold to snap to extent\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.pixelTolerance_ =\r\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\r\n\r\n    /**\r\n     * Is the pointer snapped to an extent vertex\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.snappedToVertex_ = false;\r\n\r\n    /**\r\n     * Feature for displaying the visible extent\r\n     * @type {Feature}\r\n     * @private\r\n     */\r\n    this.extentFeature_ = null;\r\n\r\n    /**\r\n     * Feature for displaying the visible pointer\r\n     * @type {Feature<Point>}\r\n     * @private\r\n     */\r\n    this.vertexFeature_ = null;\r\n\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n\r\n    /**\r\n     * Layer for the extentFeature\r\n     * @type {VectorLayer}\r\n     * @private\r\n     */\r\n    this.extentOverlay_ = new VectorLayer({\r\n      source: new VectorSource({\r\n        useSpatialIndex: false,\r\n        wrapX: !!options.wrapX,\r\n      }),\r\n      style: options.boxStyle\r\n        ? options.boxStyle\r\n        : getDefaultExtentStyleFunction(),\r\n      updateWhileAnimating: true,\r\n      updateWhileInteracting: true,\r\n    });\r\n\r\n    /**\r\n     * Layer for the vertexFeature\r\n     * @type {VectorLayer}\r\n     * @private\r\n     */\r\n    this.vertexOverlay_ = new VectorLayer({\r\n      source: new VectorSource({\r\n        useSpatialIndex: false,\r\n        wrapX: !!options.wrapX,\r\n      }),\r\n      style: options.pointerStyle\r\n        ? options.pointerStyle\r\n        : getDefaultPointerStyleFunction(),\r\n      updateWhileAnimating: true,\r\n      updateWhileInteracting: true,\r\n    });\r\n\r\n    if (options.extent) {\r\n      this.setExtent(options.extent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../pixel.js\").Pixel} pixel cursor location\r\n   * @param {import(\"../Map.js\").default} map map\r\n   * @return {import(\"../coordinate.js\").Coordinate|null} snapped vertex on extent\r\n   * @private\r\n   */\r\n  snapToVertex_(pixel, map) {\r\n    const pixelCoordinate = map.getCoordinateFromPixelInternal(pixel);\r\n    const sortByDistance = function (a, b) {\r\n      return (\r\n        squaredDistanceToSegment(pixelCoordinate, a) -\r\n        squaredDistanceToSegment(pixelCoordinate, b)\r\n      );\r\n    };\r\n    const extent = this.getExtentInternal();\r\n    if (extent) {\r\n      //convert extents to line segments and find the segment closest to pixelCoordinate\r\n      const segments = getSegments(extent);\r\n      segments.sort(sortByDistance);\r\n      const closestSegment = segments[0];\r\n\r\n      let vertex = closestOnSegment(pixelCoordinate, closestSegment);\r\n      const vertexPixel = map.getPixelFromCoordinateInternal(vertex);\r\n\r\n      //if the distance is within tolerance, snap to the segment\r\n      if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\r\n        //test if we should further snap to a vertex\r\n        const pixel1 = map.getPixelFromCoordinateInternal(closestSegment[0]);\r\n        const pixel2 = map.getPixelFromCoordinateInternal(closestSegment[1]);\r\n        const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\r\n        const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\r\n        const dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\r\n        this.snappedToVertex_ = dist <= this.pixelTolerance_;\r\n        if (this.snappedToVertex_) {\r\n          vertex =\r\n            squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\r\n        }\r\n        return vertex;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent pointer move event\r\n   * @private\r\n   */\r\n  handlePointerMove_(mapBrowserEvent) {\r\n    const pixel = mapBrowserEvent.pixel;\r\n    const map = mapBrowserEvent.map;\r\n\r\n    let vertex = this.snapToVertex_(pixel, map);\r\n    if (!vertex) {\r\n      vertex = map.getCoordinateFromPixelInternal(pixel);\r\n    }\r\n    this.createOrUpdatePointerFeature_(vertex);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../extent.js\").Extent} extent extent\r\n   * @return {Feature} extent as featrue\r\n   * @private\r\n   */\r\n  createOrUpdateExtentFeature_(extent) {\r\n    let extentFeature = this.extentFeature_;\r\n\r\n    if (!extentFeature) {\r\n      if (!extent) {\r\n        extentFeature = new Feature({});\r\n      } else {\r\n        extentFeature = new Feature(polygonFromExtent(extent));\r\n      }\r\n      this.extentFeature_ = extentFeature;\r\n      this.extentOverlay_.getSource().addFeature(extentFeature);\r\n    } else {\r\n      if (!extent) {\r\n        extentFeature.setGeometry(undefined);\r\n      } else {\r\n        extentFeature.setGeometry(polygonFromExtent(extent));\r\n      }\r\n    }\r\n    return extentFeature;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../coordinate.js\").Coordinate} vertex location of feature\r\n   * @return {Feature} vertex as feature\r\n   * @private\r\n   */\r\n  createOrUpdatePointerFeature_(vertex) {\r\n    let vertexFeature = this.vertexFeature_;\r\n    if (!vertexFeature) {\r\n      vertexFeature = new Feature(new Point(vertex));\r\n      this.vertexFeature_ = vertexFeature;\r\n      this.vertexOverlay_.getSource().addFeature(vertexFeature);\r\n    } else {\r\n      const geometry = vertexFeature.getGeometry();\r\n      geometry.setCoordinates(vertex);\r\n    }\r\n    return vertexFeature;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n   * @return {boolean} `false` to stop event propagation.\r\n   */\r\n  handleEvent(mapBrowserEvent) {\r\n    if (!mapBrowserEvent.originalEvent || !this.condition_(mapBrowserEvent)) {\r\n      return true;\r\n    }\r\n    //display pointer (if not dragging)\r\n    if (\r\n      mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&\r\n      !this.handlingDownUpSequence\r\n    ) {\r\n      this.handlePointerMove_(mapBrowserEvent);\r\n    }\r\n    //call pointer to determine up/down/drag\r\n    super.handleEvent(mapBrowserEvent);\r\n    //return false to stop propagation\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleDownEvent(mapBrowserEvent) {\r\n    const pixel = mapBrowserEvent.pixel;\r\n    const map = mapBrowserEvent.map;\r\n\r\n    const extent = this.getExtentInternal();\r\n    let vertex = this.snapToVertex_(pixel, map);\r\n\r\n    //find the extent corner opposite the passed corner\r\n    const getOpposingPoint = function (point) {\r\n      let x_ = null;\r\n      let y_ = null;\r\n      if (point[0] == extent[0]) {\r\n        x_ = extent[2];\r\n      } else if (point[0] == extent[2]) {\r\n        x_ = extent[0];\r\n      }\r\n      if (point[1] == extent[1]) {\r\n        y_ = extent[3];\r\n      } else if (point[1] == extent[3]) {\r\n        y_ = extent[1];\r\n      }\r\n      if (x_ !== null && y_ !== null) {\r\n        return [x_, y_];\r\n      }\r\n      return null;\r\n    };\r\n    if (vertex && extent) {\r\n      const x =\r\n        vertex[0] == extent[0] || vertex[0] == extent[2] ? vertex[0] : null;\r\n      const y =\r\n        vertex[1] == extent[1] || vertex[1] == extent[3] ? vertex[1] : null;\r\n\r\n      //snap to point\r\n      if (x !== null && y !== null) {\r\n        this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex));\r\n        //snap to edge\r\n      } else if (x !== null) {\r\n        this.pointerHandler_ = getEdgeHandler(\r\n          getOpposingPoint([x, extent[1]]),\r\n          getOpposingPoint([x, extent[3]])\r\n        );\r\n      } else if (y !== null) {\r\n        this.pointerHandler_ = getEdgeHandler(\r\n          getOpposingPoint([extent[0], y]),\r\n          getOpposingPoint([extent[2], y])\r\n        );\r\n      }\r\n      //no snap - new bbox\r\n    } else {\r\n      vertex = map.getCoordinateFromPixelInternal(pixel);\r\n      this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);\r\n      this.pointerHandler_ = getPointHandler(vertex);\r\n    }\r\n    return true; //event handled; start downup sequence\r\n  }\r\n\r\n  /**\r\n   * Handle pointer drag events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   */\r\n  handleDragEvent(mapBrowserEvent) {\r\n    if (this.pointerHandler_) {\r\n      const pixelCoordinate = mapBrowserEvent.coordinate;\r\n      this.setExtent(this.pointerHandler_(pixelCoordinate));\r\n      this.createOrUpdatePointerFeature_(pixelCoordinate);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleUpEvent(mapBrowserEvent) {\r\n    this.pointerHandler_ = null;\r\n    //If bbox is zero area, set to null;\r\n    const extent = this.getExtentInternal();\r\n    if (!extent || getArea(extent) === 0) {\r\n      this.setExtent(null);\r\n    }\r\n    return false; //Stop handling downup sequence\r\n  }\r\n\r\n  /**\r\n   * Remove the interaction from its current map and attach it to the new map.\r\n   * Subclasses may set up event handlers to get notified about changes to\r\n   * the map here.\r\n   * @param {import(\"../Map.js\").default} map Map.\r\n   */\r\n  setMap(map) {\r\n    this.extentOverlay_.setMap(map);\r\n    this.vertexOverlay_.setMap(map);\r\n    super.setMap(map);\r\n  }\r\n\r\n  /**\r\n   * Returns the current drawn extent in the view projection (or user projection if set)\r\n   *\r\n   * @return {import(\"../extent.js\").Extent} Drawn extent in the view projection.\r\n   * @api\r\n   */\r\n  getExtent() {\r\n    return toUserExtent(\r\n      this.getExtentInternal(),\r\n      this.getMap().getView().getProjection()\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns the current drawn extent in the view projection\r\n   *\r\n   * @return {import(\"../extent.js\").Extent} Drawn extent in the view projection.\r\n   * @api\r\n   */\r\n  getExtentInternal() {\r\n    return this.extent_;\r\n  }\r\n\r\n  /**\r\n   * Manually sets the drawn extent, using the view projection.\r\n   *\r\n   * @param {import(\"../extent.js\").Extent} extent Extent\r\n   * @api\r\n   */\r\n  setExtent(extent) {\r\n    //Null extent means no bbox\r\n    this.extent_ = extent ? extent : null;\r\n    this.createOrUpdateExtentFeature_(extent);\r\n    this.dispatchEvent(new ExtentEvent(this.extent_));\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the default style for the drawn bbox\r\n *\r\n * @return {import(\"../style/Style.js\").StyleFunction} Default Extent style\r\n */\r\nfunction getDefaultExtentStyleFunction() {\r\n  const style = createEditingStyle();\r\n  return function (feature, resolution) {\r\n    return style['Polygon'];\r\n  };\r\n}\r\n\r\n/**\r\n * Returns the default style for the pointer\r\n *\r\n * @return {import(\"../style/Style.js\").StyleFunction} Default pointer style\r\n */\r\nfunction getDefaultPointerStyleFunction() {\r\n  const style = createEditingStyle();\r\n  return function (feature, resolution) {\r\n    return style['Point'];\r\n  };\r\n}\r\n\r\n/**\r\n * @param {import(\"../coordinate.js\").Coordinate} fixedPoint corner that will be unchanged in the new extent\r\n * @return {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent} event handler\r\n */\r\nfunction getPointHandler(fixedPoint) {\r\n  return function (point) {\r\n    return boundingExtent([fixedPoint, point]);\r\n  };\r\n}\r\n\r\n/**\r\n * @param {import(\"../coordinate.js\").Coordinate} fixedP1 first corner that will be unchanged in the new extent\r\n * @param {import(\"../coordinate.js\").Coordinate} fixedP2 second corner that will be unchanged in the new extent\r\n * @return {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent|null} event handler\r\n */\r\nfunction getEdgeHandler(fixedP1, fixedP2) {\r\n  if (fixedP1[0] == fixedP2[0]) {\r\n    return function (point) {\r\n      return boundingExtent([fixedP1, [point[0], fixedP2[1]]]);\r\n    };\r\n  }\r\n  if (fixedP1[1] == fixedP2[1]) {\r\n    return function (point) {\r\n      return boundingExtent([fixedP1, [fixedP2[0], point[1]]]);\r\n    };\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * @param {import(\"../extent.js\").Extent} extent extent\r\n * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} extent line segments\r\n */\r\nfunction getSegments(extent) {\r\n  return [\r\n    [\r\n      [extent[0], extent[1]],\r\n      [extent[0], extent[3]],\r\n    ],\r\n    [\r\n      [extent[0], extent[3]],\r\n      [extent[2], extent[3]],\r\n    ],\r\n    [\r\n      [extent[2], extent[3]],\r\n      [extent[2], extent[1]],\r\n    ],\r\n    [\r\n      [extent[2], extent[1]],\r\n      [extent[0], extent[1]],\r\n    ],\r\n  ];\r\n}\r\n\r\nexport default Extent;\r\n", "/**\r\n * @module ol/interaction/Link\r\n */\r\nimport EventType from '../events/EventType.js';\r\nimport Interaction from './Interaction.js';\r\nimport MapEventType from '../MapEventType.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\nimport {toFixed} from '../math.js';\r\n\r\n/**\r\n * @param {number} number A number.\r\n * @return {number} A number with at most 5 decimal places.\r\n */\r\nfunction to5(number) {\r\n  return toFixed(number, 5);\r\n}\r\n\r\n/**\r\n * @param {string} string A string.\r\n * @return {number} A number representing the string.\r\n */\r\nfunction readNumber(string) {\r\n  return parseFloat(string);\r\n}\r\n\r\n/**\r\n * @param {number} number A number.\r\n * @return {string} A string representing the number.\r\n */\r\nfunction writeNumber(number) {\r\n  return to5(number).toString();\r\n}\r\n\r\n/**\r\n * @param {number} a A number.\r\n * @param {number} b A number.\r\n * @return {boolean} The numbers are different.\r\n */\r\nfunction differentNumber(a, b) {\r\n  if (isNaN(a)) {\r\n    return false;\r\n  }\r\n  return a !== readNumber(writeNumber(b));\r\n}\r\n\r\n/**\r\n * @param {Array<number>} a An array of two numbers.\r\n * @param {Array<number>} b An array of two numbers.\r\n * @return {boolean} The arrays are different.\r\n */\r\nfunction differentArray(a, b) {\r\n  return differentNumber(a[0], b[0]) || differentNumber(a[1], b[1]);\r\n}\r\n\r\n/** @typedef {'x'|'y'|'z'|'r'|'l'} Params */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {boolean|import('../View.js').AnimationOptions} [animate=true] Animate view transitions.\r\n * @property {Array<Params>} [params=['x', 'y', 'z', 'r', 'l']] Properties to track. Default is to track\r\n * `x` (center x), `y` (center y), `z` (zoom), `r` (rotation) and `l` (layers).\r\n * @property {boolean} [replace=false] Replace the current URL without creating the new entry in browser history.\r\n * By default, changes in the map state result in a new entry being added to the browser history.\r\n * @property {string} [prefix=''] By default, the URL will be updated with search parameters x, y, z, and r.  To\r\n * avoid collisions with existing search parameters that your application uses, you can supply a custom prefix for\r\n * the ones used by this interaction (e.g. 'ol:').\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * An interaction that synchronizes the map state with the URL.\r\n *\r\n * @api\r\n */\r\nclass Link extends Interaction {\r\n  /**\r\n   * @param {Options} [options] Link options.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    options = Object.assign(\r\n      {\r\n        animate: true,\r\n        params: ['x', 'y', 'z', 'r', 'l'],\r\n        replace: false,\r\n        prefix: '',\r\n      },\r\n      options || {}\r\n    );\r\n\r\n    let animationOptions;\r\n    if (options.animate === true) {\r\n      animationOptions = {duration: 250};\r\n    } else if (!options.animate) {\r\n      animationOptions = null;\r\n    } else {\r\n      animationOptions = options.animate;\r\n    }\r\n\r\n    /**\r\n     * @type {import('../View.js').AnimationOptions|null}\r\n     * @private\r\n     */\r\n    this.animationOptions_ = animationOptions;\r\n\r\n    /**\r\n     * @type {Object<Params, boolean>}\r\n     * @private\r\n     */\r\n    this.params_ = options.params.reduce((acc, value) => {\r\n      acc[value] = true;\r\n      return acc;\r\n    }, {});\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.replace_ = options.replace;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.prefix_ = options.prefix;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Array<import(\"../events.js\").EventsKey>}\r\n     */\r\n    this.listenerKeys_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.initial_ = true;\r\n\r\n    this.updateState_ = this.updateState_.bind(this);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {string} name A parameter name.\r\n   * @return {string} A name with the prefix applied.\r\n   */\r\n  getParamName_(name) {\r\n    if (!this.prefix_) {\r\n      return name;\r\n    }\r\n    return this.prefix_ + name;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {URLSearchParams} params The search params.\r\n   * @param {string} name The unprefixed parameter name.\r\n   * @return {string|null} The parameter value.\r\n   */\r\n  get_(params, name) {\r\n    return params.get(this.getParamName_(name));\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {URLSearchParams} params The search params.\r\n   * @param {string} name The unprefixed parameter name.\r\n   * @param {string} value The param value.\r\n   */\r\n  set_(params, name, value) {\r\n    if (!(name in this.params_)) {\r\n      return;\r\n    }\r\n    params.set(this.getParamName_(name), value);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {URLSearchParams} params The search params.\r\n   * @param {string} name The unprefixed parameter name.\r\n   */\r\n  delete_(params, name) {\r\n    if (!(name in this.params_)) {\r\n      return;\r\n    }\r\n    params.delete(this.getParamName_(name));\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Map.js\").default|null} map Map.\r\n   */\r\n  setMap(map) {\r\n    const oldMap = this.getMap();\r\n    super.setMap(map);\r\n    if (map === oldMap) {\r\n      return;\r\n    }\r\n    if (oldMap) {\r\n      this.unregisterListeners_(oldMap);\r\n    }\r\n    if (map) {\r\n      this.initial_ = true;\r\n      this.updateState_();\r\n      this.registerListeners_(map);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Map.js\").default} map Map.\r\n   * @private\r\n   */\r\n  registerListeners_(map) {\r\n    this.listenerKeys_.push(\r\n      listen(map, MapEventType.MOVEEND, this.updateUrl_, this),\r\n      listen(map.getLayerGroup(), EventType.CHANGE, this.updateUrl_, this),\r\n      listen(map, 'change:layergroup', this.handleChangeLayerGroup_, this)\r\n    );\r\n\r\n    if (!this.replace_) {\r\n      addEventListener('popstate', this.updateState_);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Map.js\").default} map Map.\r\n   * @private\r\n   */\r\n  unregisterListeners_(map) {\r\n    for (let i = 0, ii = this.listenerKeys_.length; i < ii; ++i) {\r\n      unlistenByKey(this.listenerKeys_[i]);\r\n    }\r\n    this.listenerKeys_.length = 0;\r\n\r\n    if (!this.replace_) {\r\n      removeEventListener('popstate', this.updateState_);\r\n    }\r\n\r\n    const url = new URL(window.location.href);\r\n    const params = url.searchParams;\r\n    this.delete_(params, 'x');\r\n    this.delete_(params, 'y');\r\n    this.delete_(params, 'z');\r\n    this.delete_(params, 'r');\r\n    this.delete_(params, 'l');\r\n    window.history.replaceState(null, '', url);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  handleChangeLayerGroup_() {\r\n    const map = this.getMap();\r\n    if (!map) {\r\n      return;\r\n    }\r\n    this.unregisterListeners_(map);\r\n    this.registerListeners_(map);\r\n    this.initial_ = true;\r\n    this.updateUrl_();\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  updateState_() {\r\n    const map = this.getMap();\r\n    if (!map) {\r\n      return;\r\n    }\r\n    const view = map.getView();\r\n    if (!view) {\r\n      return;\r\n    }\r\n    const url = new URL(window.location.href);\r\n    const params = url.searchParams;\r\n\r\n    let updateView = false;\r\n\r\n    /**\r\n     * @type {import('../View.js').AnimationOptions}\r\n     */\r\n    const viewProperties = {};\r\n\r\n    const zoom = readNumber(this.get_(params, 'z'));\r\n    if ('z' in this.params_ && differentNumber(zoom, view.getZoom())) {\r\n      updateView = true;\r\n      viewProperties.zoom = zoom;\r\n    }\r\n\r\n    const rotation = readNumber(this.get_(params, 'r'));\r\n    if ('r' in this.params_ && differentNumber(rotation, view.getRotation())) {\r\n      updateView = true;\r\n      viewProperties.rotation = rotation;\r\n    }\r\n\r\n    const center = [\r\n      readNumber(this.get_(params, 'x')),\r\n      readNumber(this.get_(params, 'y')),\r\n    ];\r\n    if (\r\n      ('x' in this.params_ || 'y' in this.params_) &&\r\n      differentArray(center, view.getCenter())\r\n    ) {\r\n      updateView = true;\r\n      viewProperties.center = center;\r\n    }\r\n\r\n    if (updateView) {\r\n      if (!this.initial_ && this.animationOptions_) {\r\n        view.animate(Object.assign(viewProperties, this.animationOptions_));\r\n      } else {\r\n        if (viewProperties.center) {\r\n          view.setCenter(viewProperties.center);\r\n        }\r\n        if ('zoom' in viewProperties) {\r\n          view.setZoom(viewProperties.zoom);\r\n        }\r\n        if ('rotation' in viewProperties) {\r\n          view.setRotation(viewProperties.rotation);\r\n        }\r\n      }\r\n    }\r\n\r\n    const layers = map.getAllLayers();\r\n    const layersParam = this.get_(params, 'l');\r\n    if (\r\n      'l' in this.params_ &&\r\n      layersParam &&\r\n      layersParam.length === layers.length\r\n    ) {\r\n      for (let i = 0, ii = layers.length; i < ii; ++i) {\r\n        const value = parseInt(layersParam[i]);\r\n        if (!isNaN(value)) {\r\n          const visible = Boolean(value);\r\n          const layer = layers[i];\r\n          if (layer.getVisible() !== visible) {\r\n            layer.setVisible(visible);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  updateUrl_() {\r\n    const map = this.getMap();\r\n    if (!map) {\r\n      return;\r\n    }\r\n    const view = map.getView();\r\n    if (!view) {\r\n      return;\r\n    }\r\n    const initial = this.initial_;\r\n    this.initial_ = false;\r\n\r\n    const center = view.getCenter();\r\n    const zoom = view.getZoom();\r\n    const rotation = view.getRotation();\r\n\r\n    const layers = map.getAllLayers();\r\n    const visibilities = new Array(layers.length);\r\n    for (let i = 0, ii = layers.length; i < ii; ++i) {\r\n      visibilities[i] = layers[i].getVisible() ? '1' : '0';\r\n    }\r\n\r\n    const url = new URL(window.location.href);\r\n    const params = url.searchParams;\r\n\r\n    this.set_(params, 'x', writeNumber(center[0]));\r\n    this.set_(params, 'y', writeNumber(center[1]));\r\n    this.set_(params, 'z', writeNumber(zoom));\r\n    this.set_(params, 'r', writeNumber(rotation));\r\n    this.set_(params, 'l', visibilities.join(''));\r\n\r\n    if (url.href !== window.location.href) {\r\n      if (initial || this.replace_) {\r\n        window.history.replaceState(history.state, '', url);\r\n      } else {\r\n        window.history.pushState(null, '', url);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default Link;\r\n", "/**\r\n * @module ol/interaction/Modify\r\n */\r\nimport Collection from '../Collection.js';\r\nimport CollectionEventType from '../CollectionEventType.js';\r\nimport Event from '../events/Event.js';\r\nimport EventType from '../events/EventType.js';\r\nimport Feature from '../Feature.js';\r\nimport MapBrowserEventType from '../MapBrowserEventType.js';\r\nimport Point from '../geom/Point.js';\r\nimport PointerInteraction from './Pointer.js';\r\nimport RBush from '../structs/RBush.js';\r\nimport VectorEventType from '../source/VectorEventType.js';\r\nimport VectorLayer from '../layer/Vector.js';\r\nimport VectorSource from '../source/Vector.js';\r\nimport {\r\n  altKeyOnly,\r\n  always,\r\n  primaryAction,\r\n  singleClick,\r\n} from '../events/condition.js';\r\nimport {\r\n  boundingExtent,\r\n  buffer as bufferExtent,\r\n  createOrUpdateFromCoordinate as createExtent,\r\n} from '../extent.js';\r\nimport {\r\n  closestOnSegment,\r\n  distance as coordinateDistance,\r\n  equals as coordinatesEqual,\r\n  squaredDistance as squaredCoordinateDistance,\r\n  squaredDistanceToSegment,\r\n} from '../coordinate.js';\r\nimport {createEditingStyle} from '../style/Style.js';\r\nimport {equals} from '../array.js';\r\nimport {fromCircle} from '../geom/Polygon.js';\r\nimport {\r\n  fromUserCoordinate,\r\n  fromUserExtent,\r\n  getUserProjection,\r\n  toUserCoordinate,\r\n  toUserExtent,\r\n} from '../proj.js';\r\nimport {getUid} from '../util.js';\r\n\r\n/**\r\n * The segment index assigned to a circle's center when\r\n * breaking up a circle into ModifySegmentDataType segments.\r\n * @type {number}\r\n */\r\nconst CIRCLE_CENTER_INDEX = 0;\r\n\r\n/**\r\n * The segment index assigned to a circle's circumference when\r\n * breaking up a circle into ModifySegmentDataType segments.\r\n * @type {number}\r\n */\r\nconst CIRCLE_CIRCUMFERENCE_INDEX = 1;\r\n\r\nconst tempExtent = [0, 0, 0, 0];\r\nconst tempSegment = [];\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nconst ModifyEventType = {\r\n  /**\r\n   * Triggered upon feature modification start\r\n   * @event ModifyEvent#modifystart\r\n   * @api\r\n   */\r\n  MODIFYSTART: 'modifystart',\r\n  /**\r\n   * Triggered upon feature modification end\r\n   * @event ModifyEvent#modifyend\r\n   * @api\r\n   */\r\n  MODIFYEND: 'modifyend',\r\n};\r\n\r\n/**\r\n * @typedef {Object} SegmentData\r\n * @property {Array<number>} [depth] Depth.\r\n * @property {Feature} feature Feature.\r\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\r\n * @property {number} [index] Index.\r\n * @property {Array<Array<number>>} segment Segment.\r\n * @property {Array<SegmentData>} [featureSegments] FeatureSegments.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\r\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event will be considered to add or move a\r\n * vertex to the sketch. Default is\r\n * {@link module:ol/events/condition.primaryAction}.\r\n * @property {import(\"../events/condition.js\").Condition} [deleteCondition] A function\r\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event should be handled. By default,\r\n * {@link module:ol/events/condition.singleClick} with\r\n * {@link module:ol/events/condition.altKeyOnly} results in a vertex deletion.\r\n * @property {import(\"../events/condition.js\").Condition} [insertVertexCondition] A\r\n * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\r\n * returns a boolean to indicate whether a new vertex should be added to the sketch\r\n * features. Default is {@link module:ol/events/condition.always}.\r\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the\r\n * pointer close enough to a segment or vertex for editing.\r\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\r\n * Style used for the modification point or vertex. For linestrings and polygons, this will\r\n * be the affected vertex, for circles a point along the circle, and for points the actual\r\n * point. If not configured, the default edit style is used (see {@link module:ol/style/Style~Style}).\r\n * When using a style function, the point feature passed to the function will have a `features`\r\n * property - an array whose entries are the features that are being modified, and a `geometries`\r\n * property - an array whose entries are the geometries that are being modified. Both arrays are\r\n * in the same order. The `geometries` are only useful when modifying geometry collections, where\r\n * the geometry will be the particular geometry from the collection that is being modified.\r\n * @property {VectorSource} [source] The vector source with\r\n * features to modify.  If a vector source is not provided, a feature collection\r\n * must be provided with the `features` option.\r\n * @property {boolean|import(\"../layer/BaseVector\").default} [hitDetection] When configured, point\r\n * features will be considered for modification based on their visual appearance, instead of being within\r\n * the `pixelTolerance` from the pointer location. When a {@link module:ol/layer/BaseVector~BaseVectorLayer} is\r\n * provided, only the rendered representation of the features on that layer will be considered.\r\n * @property {Collection<Feature>} [features]\r\n * The features the interaction works on.  If a feature collection is not\r\n * provided, a vector source must be provided with the `source` option.\r\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\r\n * overlay.\r\n * @property {boolean} [snapToPointer=!hitDetection] The vertex, point or segment being modified snaps to the\r\n * pointer coordinate when clicked within the `pixelTolerance`.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are\r\n * instances of this type.\r\n */\r\nexport class ModifyEvent extends Event {\r\n  /**\r\n   * @param {ModifyEventType} type Type.\r\n   * @param {Collection<Feature>} features\r\n   * The features modified.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent\r\n   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\r\n   */\r\n  constructor(type, features, mapBrowserEvent) {\r\n    super(type);\r\n\r\n    /**\r\n     * The features being modified.\r\n     * @type {Collection<Feature>}\r\n     * @api\r\n     */\r\n    this.features = features;\r\n\r\n    /**\r\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\r\n     * @type {import(\"../MapBrowserEvent.js\").default}\r\n     * @api\r\n     */\r\n    this.mapBrowserEvent = mapBrowserEvent;\r\n  }\r\n}\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\r\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<'modifyend'|'modifystart', ModifyEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\r\n *     'change:active'|'modifyend'|'modifystart', Return>} ModifyOnSignature\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Interaction for modifying feature geometries.  To modify features that have\r\n * been added to an existing source, construct the modify interaction with the\r\n * `source` option.  If you want to modify features in a collection (for example,\r\n * the collection used by a select interaction), construct the interaction with\r\n * the `features` option.  The interaction must be constructed with either a\r\n * `source` or `features` option.\r\n *\r\n * Cartesian distance from the pointer is used to determine the features that\r\n * will be modified. This means that geometries will only be considered for\r\n * modification when they are within the configured `pixelTolerance`. For point\r\n * geometries, the `hitDetection` option can be used to match their visual\r\n * appearance.\r\n *\r\n * By default, the interaction will allow deletion of vertices when the `alt`\r\n * key is pressed.  To configure the interaction with a different condition\r\n * for deletion, use the `deleteCondition` option.\r\n * @fires ModifyEvent\r\n * @api\r\n */\r\nclass Modify extends PointerInteraction {\r\n  /**\r\n   * @param {Options} options Options.\r\n   */\r\n  constructor(options) {\r\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\r\n\r\n    /***\r\n     * @type {ModifyOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {ModifyOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {ModifyOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /** @private */\r\n    this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this);\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\r\n    this.condition_ = options.condition ? options.condition : primaryAction;\r\n\r\n    /**\r\n     * @private\r\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Browser event.\r\n     * @return {boolean} Combined condition result.\r\n     */\r\n    this.defaultDeleteCondition_ = function (mapBrowserEvent) {\r\n      return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);\r\n    };\r\n\r\n    /**\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     * @private\r\n     */\r\n    this.deleteCondition_ = options.deleteCondition\r\n      ? options.deleteCondition\r\n      : this.defaultDeleteCondition_;\r\n\r\n    /**\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     * @private\r\n     */\r\n    this.insertVertexCondition_ = options.insertVertexCondition\r\n      ? options.insertVertexCondition\r\n      : always;\r\n\r\n    /**\r\n     * Editing vertex.\r\n     * @type {Feature<Point>}\r\n     * @private\r\n     */\r\n    this.vertexFeature_ = null;\r\n\r\n    /**\r\n     * Segments intersecting {@link this.vertexFeature_} by segment uid.\r\n     * @type {Object<string, boolean>}\r\n     * @private\r\n     */\r\n    this.vertexSegments_ = null;\r\n\r\n    /**\r\n     * @type {import(\"../pixel.js\").Pixel}\r\n     * @private\r\n     */\r\n    this.lastPixel_ = [0, 0];\r\n\r\n    /**\r\n     * Tracks if the next `singleclick` event should be ignored to prevent\r\n     * accidental deletion right after vertex creation.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.ignoreNextSingleClick_ = false;\r\n\r\n    /**\r\n     * @type {Collection<Feature>}\r\n     * @private\r\n     */\r\n    this.featuresBeingModified_ = null;\r\n\r\n    /**\r\n     * Segment RTree for each layer\r\n     * @type {RBush<SegmentData>}\r\n     * @private\r\n     */\r\n    this.rBush_ = new RBush();\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.pixelTolerance_ =\r\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.snappedToVertex_ = false;\r\n\r\n    /**\r\n     * Indicate whether the interaction is currently changing a feature's\r\n     * coordinates.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.changingFeature_ = false;\r\n\r\n    /**\r\n     * @type {Array}\r\n     * @private\r\n     */\r\n    this.dragSegments_ = [];\r\n\r\n    /**\r\n     * Draw overlay where sketch features are drawn.\r\n     * @type {VectorLayer}\r\n     * @private\r\n     */\r\n    this.overlay_ = new VectorLayer({\r\n      source: new VectorSource({\r\n        useSpatialIndex: false,\r\n        wrapX: !!options.wrapX,\r\n      }),\r\n      style: options.style ? options.style : getDefaultStyleFunction(),\r\n      updateWhileAnimating: true,\r\n      updateWhileInteracting: true,\r\n    });\r\n\r\n    /**\r\n     * @const\r\n     * @private\r\n     * @type {!Object<string, function(Feature, import(\"../geom/Geometry.js\").default): void>}\r\n     */\r\n    this.SEGMENT_WRITERS_ = {\r\n      'Point': this.writePointGeometry_.bind(this),\r\n      'LineString': this.writeLineStringGeometry_.bind(this),\r\n      'LinearRing': this.writeLineStringGeometry_.bind(this),\r\n      'Polygon': this.writePolygonGeometry_.bind(this),\r\n      'MultiPoint': this.writeMultiPointGeometry_.bind(this),\r\n      'MultiLineString': this.writeMultiLineStringGeometry_.bind(this),\r\n      'MultiPolygon': this.writeMultiPolygonGeometry_.bind(this),\r\n      'Circle': this.writeCircleGeometry_.bind(this),\r\n      'GeometryCollection': this.writeGeometryCollectionGeometry_.bind(this),\r\n    };\r\n\r\n    /**\r\n     * @type {VectorSource}\r\n     * @private\r\n     */\r\n    this.source_ = null;\r\n\r\n    /**\r\n     * @type {boolean|import(\"../layer/BaseVector\").default}\r\n     */\r\n    this.hitDetection_ = null;\r\n\r\n    /** @type {Collection<Feature>} */\r\n    let features;\r\n    if (options.features) {\r\n      features = options.features;\r\n    } else if (options.source) {\r\n      this.source_ = options.source;\r\n      features = new Collection(this.source_.getFeatures());\r\n      this.source_.addEventListener(\r\n        VectorEventType.ADDFEATURE,\r\n        this.handleSourceAdd_.bind(this)\r\n      );\r\n      this.source_.addEventListener(\r\n        VectorEventType.REMOVEFEATURE,\r\n        this.handleSourceRemove_.bind(this)\r\n      );\r\n    }\r\n    if (!features) {\r\n      throw new Error(\r\n        'The modify interaction requires features, a source or a layer'\r\n      );\r\n    }\r\n    if (options.hitDetection) {\r\n      this.hitDetection_ = options.hitDetection;\r\n    }\r\n\r\n    /**\r\n     * @type {Collection<Feature>}\r\n     * @private\r\n     */\r\n    this.features_ = features;\r\n\r\n    this.features_.forEach(this.addFeature_.bind(this));\r\n    this.features_.addEventListener(\r\n      CollectionEventType.ADD,\r\n      this.handleFeatureAdd_.bind(this)\r\n    );\r\n    this.features_.addEventListener(\r\n      CollectionEventType.REMOVE,\r\n      this.handleFeatureRemove_.bind(this)\r\n    );\r\n\r\n    /**\r\n     * @type {import(\"../MapBrowserEvent.js\").default}\r\n     * @private\r\n     */\r\n    this.lastPointerEvent_ = null;\r\n\r\n    /**\r\n     * Delta (x, y in map units) between matched rtree vertex and pointer vertex.\r\n     * @type {Array<number>}\r\n     */\r\n    this.delta_ = [0, 0];\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.snapToPointer_ =\r\n      options.snapToPointer === undefined\r\n        ? !this.hitDetection_\r\n        : options.snapToPointer;\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature.\r\n   * @private\r\n   */\r\n  addFeature_(feature) {\r\n    const geometry = feature.getGeometry();\r\n    if (geometry) {\r\n      const writer = this.SEGMENT_WRITERS_[geometry.getType()];\r\n      if (writer) {\r\n        writer(feature, geometry);\r\n      }\r\n    }\r\n    const map = this.getMap();\r\n    if (map && map.isRendered() && this.getActive()) {\r\n      this.handlePointerAtPixel_(this.lastPixel_, map);\r\n    }\r\n    feature.addEventListener(EventType.CHANGE, this.boundHandleFeatureChange_);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\r\n   * @param {Array<Array<SegmentData>>} segments The segments subject to modification.\r\n   * @private\r\n   */\r\n  willModifyFeatures_(evt, segments) {\r\n    if (!this.featuresBeingModified_) {\r\n      this.featuresBeingModified_ = new Collection();\r\n      const features = this.featuresBeingModified_.getArray();\r\n      for (let i = 0, ii = segments.length; i < ii; ++i) {\r\n        const segment = segments[i];\r\n        for (let s = 0, ss = segment.length; s < ss; ++s) {\r\n          const feature = segment[s].feature;\r\n          if (feature && !features.includes(feature)) {\r\n            this.featuresBeingModified_.push(feature);\r\n          }\r\n        }\r\n      }\r\n      if (this.featuresBeingModified_.getLength() === 0) {\r\n        this.featuresBeingModified_ = null;\r\n      } else {\r\n        this.dispatchEvent(\r\n          new ModifyEvent(\r\n            ModifyEventType.MODIFYSTART,\r\n            this.featuresBeingModified_,\r\n            evt\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature.\r\n   * @private\r\n   */\r\n  removeFeature_(feature) {\r\n    this.removeFeatureSegmentData_(feature);\r\n    // Remove the vertex feature if the collection of candidate features is empty.\r\n    if (this.vertexFeature_ && this.features_.getLength() === 0) {\r\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\r\n      this.vertexFeature_ = null;\r\n    }\r\n    feature.removeEventListener(\r\n      EventType.CHANGE,\r\n      this.boundHandleFeatureChange_\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature.\r\n   * @private\r\n   */\r\n  removeFeatureSegmentData_(feature) {\r\n    const rBush = this.rBush_;\r\n    /** @type {Array<SegmentData>} */\r\n    const nodesToRemove = [];\r\n    rBush.forEach(\r\n      /**\r\n       * @param {SegmentData} node RTree node.\r\n       */\r\n      function (node) {\r\n        if (feature === node.feature) {\r\n          nodesToRemove.push(node);\r\n        }\r\n      }\r\n    );\r\n    for (let i = nodesToRemove.length - 1; i >= 0; --i) {\r\n      const nodeToRemove = nodesToRemove[i];\r\n      for (let j = this.dragSegments_.length - 1; j >= 0; --j) {\r\n        if (this.dragSegments_[j][0] === nodeToRemove) {\r\n          this.dragSegments_.splice(j, 1);\r\n        }\r\n      }\r\n      rBush.remove(nodeToRemove);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activate or deactivate the interaction.\r\n   * @param {boolean} active Active.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setActive(active) {\r\n    if (this.vertexFeature_ && !active) {\r\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\r\n      this.vertexFeature_ = null;\r\n    }\r\n    super.setActive(active);\r\n  }\r\n\r\n  /**\r\n   * Remove the interaction from its current map and attach it to the new map.\r\n   * Subclasses may set up event handlers to get notified about changes to\r\n   * the map here.\r\n   * @param {import(\"../Map.js\").default} map Map.\r\n   */\r\n  setMap(map) {\r\n    this.overlay_.setMap(map);\r\n    super.setMap(map);\r\n  }\r\n\r\n  /**\r\n   * Get the overlay layer that this interaction renders the modification point or vertex to.\r\n   * @return {VectorLayer} Overlay layer.\r\n   * @api\r\n   */\r\n  getOverlay() {\r\n    return this.overlay_;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent} event Event.\r\n   * @private\r\n   */\r\n  handleSourceAdd_(event) {\r\n    if (event.feature) {\r\n      this.features_.push(event.feature);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent} event Event.\r\n   * @private\r\n   */\r\n  handleSourceRemove_(event) {\r\n    if (event.feature) {\r\n      this.features_.remove(event.feature);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\r\n   * @private\r\n   */\r\n  handleFeatureAdd_(evt) {\r\n    this.addFeature_(evt.element);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../events/Event.js\").default} evt Event.\r\n   * @private\r\n   */\r\n  handleFeatureChange_(evt) {\r\n    if (!this.changingFeature_) {\r\n      const feature = /** @type {Feature} */ (evt.target);\r\n      this.removeFeature_(feature);\r\n      this.addFeature_(feature);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\r\n   * @private\r\n   */\r\n  handleFeatureRemove_(evt) {\r\n    this.removeFeature_(evt.element);\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature\r\n   * @param {Point} geometry Geometry.\r\n   * @private\r\n   */\r\n  writePointGeometry_(feature, geometry) {\r\n    const coordinates = geometry.getCoordinates();\r\n\r\n    /** @type {SegmentData} */\r\n    const segmentData = {\r\n      feature: feature,\r\n      geometry: geometry,\r\n      segment: [coordinates, coordinates],\r\n    };\r\n\r\n    this.rBush_.insert(geometry.getExtent(), segmentData);\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature\r\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  writeMultiPointGeometry_(feature, geometry) {\r\n    const points = geometry.getCoordinates();\r\n    for (let i = 0, ii = points.length; i < ii; ++i) {\r\n      const coordinates = points[i];\r\n\r\n      /** @type {SegmentData} */\r\n      const segmentData = {\r\n        feature: feature,\r\n        geometry: geometry,\r\n        depth: [i],\r\n        index: i,\r\n        segment: [coordinates, coordinates],\r\n      };\r\n\r\n      this.rBush_.insert(geometry.getExtent(), segmentData);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature\r\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  writeLineStringGeometry_(feature, geometry) {\r\n    const coordinates = geometry.getCoordinates();\r\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\r\n      const segment = coordinates.slice(i, i + 2);\r\n\r\n      /** @type {SegmentData} */\r\n      const segmentData = {\r\n        feature: feature,\r\n        geometry: geometry,\r\n        index: i,\r\n        segment: segment,\r\n      };\r\n\r\n      this.rBush_.insert(boundingExtent(segment), segmentData);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature\r\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  writeMultiLineStringGeometry_(feature, geometry) {\r\n    const lines = geometry.getCoordinates();\r\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\r\n      const coordinates = lines[j];\r\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\r\n        const segment = coordinates.slice(i, i + 2);\r\n\r\n        /** @type {SegmentData} */\r\n        const segmentData = {\r\n          feature: feature,\r\n          geometry: geometry,\r\n          depth: [j],\r\n          index: i,\r\n          segment: segment,\r\n        };\r\n\r\n        this.rBush_.insert(boundingExtent(segment), segmentData);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature\r\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  writePolygonGeometry_(feature, geometry) {\r\n    const rings = geometry.getCoordinates();\r\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\r\n      const coordinates = rings[j];\r\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\r\n        const segment = coordinates.slice(i, i + 2);\r\n\r\n        /** @type {SegmentData} */\r\n        const segmentData = {\r\n          feature: feature,\r\n          geometry: geometry,\r\n          depth: [j],\r\n          index: i,\r\n          segment: segment,\r\n        };\r\n\r\n        this.rBush_.insert(boundingExtent(segment), segmentData);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature\r\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  writeMultiPolygonGeometry_(feature, geometry) {\r\n    const polygons = geometry.getCoordinates();\r\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\r\n      const rings = polygons[k];\r\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\r\n        const coordinates = rings[j];\r\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\r\n          const segment = coordinates.slice(i, i + 2);\r\n\r\n          /** @type {SegmentData} */\r\n          const segmentData = {\r\n            feature: feature,\r\n            geometry: geometry,\r\n            depth: [j, k],\r\n            index: i,\r\n            segment: segment,\r\n          };\r\n\r\n          this.rBush_.insert(boundingExtent(segment), segmentData);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * We convert a circle into two segments.  The segment at index\r\n   * {@link CIRCLE_CENTER_INDEX} is the\r\n   * circle's center (a point).  The segment at index\r\n   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is\r\n   * the circumference, and is not a line segment.\r\n   *\r\n   * @param {Feature} feature Feature.\r\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  writeCircleGeometry_(feature, geometry) {\r\n    const coordinates = geometry.getCenter();\r\n\r\n    /** @type {SegmentData} */\r\n    const centerSegmentData = {\r\n      feature: feature,\r\n      geometry: geometry,\r\n      index: CIRCLE_CENTER_INDEX,\r\n      segment: [coordinates, coordinates],\r\n    };\r\n\r\n    /** @type {SegmentData} */\r\n    const circumferenceSegmentData = {\r\n      feature: feature,\r\n      geometry: geometry,\r\n      index: CIRCLE_CIRCUMFERENCE_INDEX,\r\n      segment: [coordinates, coordinates],\r\n    };\r\n\r\n    const featureSegments = [centerSegmentData, circumferenceSegmentData];\r\n    centerSegmentData.featureSegments = featureSegments;\r\n    circumferenceSegmentData.featureSegments = featureSegments;\r\n    this.rBush_.insert(createExtent(coordinates), centerSegmentData);\r\n    let circleGeometry = /** @type {import(\"../geom/Geometry.js\").default} */ (\r\n      geometry\r\n    );\r\n    const userProjection = getUserProjection();\r\n    if (userProjection && this.getMap()) {\r\n      const projection = this.getMap().getView().getProjection();\r\n      circleGeometry = circleGeometry\r\n        .clone()\r\n        .transform(userProjection, projection);\r\n      circleGeometry = fromCircle(\r\n        /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry)\r\n      ).transform(projection, userProjection);\r\n    }\r\n    this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature\r\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  writeGeometryCollectionGeometry_(feature, geometry) {\r\n    const geometries = geometry.getGeometriesArray();\r\n    for (let i = 0; i < geometries.length; ++i) {\r\n      const geometry = geometries[i];\r\n      const writer = this.SEGMENT_WRITERS_[geometry.getType()];\r\n      writer(feature, geometry);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\r\n   * @param {Array<Feature>} features The features being modified.\r\n   * @param {Array<import(\"../geom/SimpleGeometry.js\").default>} geometries The geometries being modified.\r\n   * @return {Feature} Vertex feature.\r\n   * @private\r\n   */\r\n  createOrUpdateVertexFeature_(coordinates, features, geometries) {\r\n    let vertexFeature = this.vertexFeature_;\r\n    if (!vertexFeature) {\r\n      vertexFeature = new Feature(new Point(coordinates));\r\n      this.vertexFeature_ = vertexFeature;\r\n      this.overlay_.getSource().addFeature(vertexFeature);\r\n    } else {\r\n      const geometry = vertexFeature.getGeometry();\r\n      geometry.setCoordinates(coordinates);\r\n    }\r\n    vertexFeature.set('features', features);\r\n    vertexFeature.set('geometries', geometries);\r\n    return vertexFeature;\r\n  }\r\n\r\n  /**\r\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n   * @return {boolean} `false` to stop event propagation.\r\n   */\r\n  handleEvent(mapBrowserEvent) {\r\n    if (!mapBrowserEvent.originalEvent) {\r\n      return true;\r\n    }\r\n    this.lastPointerEvent_ = mapBrowserEvent;\r\n\r\n    let handled;\r\n    if (\r\n      !mapBrowserEvent.map.getView().getInteracting() &&\r\n      mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&\r\n      !this.handlingDownUpSequence\r\n    ) {\r\n      this.handlePointerMove_(mapBrowserEvent);\r\n    }\r\n    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {\r\n      if (\r\n        mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK ||\r\n        !this.ignoreNextSingleClick_\r\n      ) {\r\n        handled = this.removePoint();\r\n      } else {\r\n        handled = true;\r\n      }\r\n    }\r\n\r\n    if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {\r\n      this.ignoreNextSingleClick_ = false;\r\n    }\r\n\r\n    return super.handleEvent(mapBrowserEvent) && !handled;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer drag events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\r\n   */\r\n  handleDragEvent(evt) {\r\n    this.ignoreNextSingleClick_ = false;\r\n    this.willModifyFeatures_(evt, this.dragSegments_);\r\n\r\n    const vertex = [\r\n      evt.coordinate[0] + this.delta_[0],\r\n      evt.coordinate[1] + this.delta_[1],\r\n    ];\r\n    const features = [];\r\n    const geometries = [];\r\n    for (let i = 0, ii = this.dragSegments_.length; i < ii; ++i) {\r\n      const dragSegment = this.dragSegments_[i];\r\n      const segmentData = dragSegment[0];\r\n      const feature = segmentData.feature;\r\n      if (!features.includes(feature)) {\r\n        features.push(feature);\r\n      }\r\n      const geometry = segmentData.geometry;\r\n      if (!geometries.includes(geometry)) {\r\n        geometries.push(geometry);\r\n      }\r\n      const depth = segmentData.depth;\r\n      let coordinates;\r\n      const segment = segmentData.segment;\r\n      const index = dragSegment[1];\r\n\r\n      while (vertex.length < geometry.getStride()) {\r\n        vertex.push(segment[index][vertex.length]);\r\n      }\r\n\r\n      switch (geometry.getType()) {\r\n        case 'Point':\r\n          coordinates = vertex;\r\n          segment[0] = vertex;\r\n          segment[1] = vertex;\r\n          break;\r\n        case 'MultiPoint':\r\n          coordinates = geometry.getCoordinates();\r\n          coordinates[segmentData.index] = vertex;\r\n          segment[0] = vertex;\r\n          segment[1] = vertex;\r\n          break;\r\n        case 'LineString':\r\n          coordinates = geometry.getCoordinates();\r\n          coordinates[segmentData.index + index] = vertex;\r\n          segment[index] = vertex;\r\n          break;\r\n        case 'MultiLineString':\r\n          coordinates = geometry.getCoordinates();\r\n          coordinates[depth[0]][segmentData.index + index] = vertex;\r\n          segment[index] = vertex;\r\n          break;\r\n        case 'Polygon':\r\n          coordinates = geometry.getCoordinates();\r\n          coordinates[depth[0]][segmentData.index + index] = vertex;\r\n          segment[index] = vertex;\r\n          break;\r\n        case 'MultiPolygon':\r\n          coordinates = geometry.getCoordinates();\r\n          coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;\r\n          segment[index] = vertex;\r\n          break;\r\n        case 'Circle':\r\n          segment[0] = vertex;\r\n          segment[1] = vertex;\r\n          if (segmentData.index === CIRCLE_CENTER_INDEX) {\r\n            this.changingFeature_ = true;\r\n            geometry.setCenter(vertex);\r\n            this.changingFeature_ = false;\r\n          } else {\r\n            // We're dragging the circle's circumference:\r\n            this.changingFeature_ = true;\r\n            const projection = evt.map.getView().getProjection();\r\n            let radius = coordinateDistance(\r\n              fromUserCoordinate(geometry.getCenter(), projection),\r\n              fromUserCoordinate(vertex, projection)\r\n            );\r\n            const userProjection = getUserProjection();\r\n            if (userProjection) {\r\n              const circleGeometry = geometry\r\n                .clone()\r\n                .transform(userProjection, projection);\r\n              circleGeometry.setRadius(radius);\r\n              radius = circleGeometry\r\n                .transform(projection, userProjection)\r\n                .getRadius();\r\n            }\r\n            geometry.setRadius(radius);\r\n            this.changingFeature_ = false;\r\n          }\r\n          break;\r\n        default:\r\n        // pass\r\n      }\r\n\r\n      if (coordinates) {\r\n        this.setGeometryCoordinates_(geometry, coordinates);\r\n      }\r\n    }\r\n    this.createOrUpdateVertexFeature_(vertex, features, geometries);\r\n  }\r\n\r\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleDownEvent(evt) {\r\n    if (!this.condition_(evt)) {\r\n      return false;\r\n    }\r\n    const pixelCoordinate = evt.coordinate;\r\n    this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);\r\n    this.dragSegments_.length = 0;\r\n    this.featuresBeingModified_ = null;\r\n    const vertexFeature = this.vertexFeature_;\r\n    if (vertexFeature) {\r\n      const projection = evt.map.getView().getProjection();\r\n      const insertVertices = [];\r\n      const vertex = vertexFeature.getGeometry().getCoordinates();\r\n      const vertexExtent = boundingExtent([vertex]);\r\n      const segmentDataMatches = this.rBush_.getInExtent(vertexExtent);\r\n      const componentSegments = {};\r\n      segmentDataMatches.sort(compareIndexes);\r\n      for (let i = 0, ii = segmentDataMatches.length; i < ii; ++i) {\r\n        const segmentDataMatch = segmentDataMatches[i];\r\n        const segment = segmentDataMatch.segment;\r\n        let uid = getUid(segmentDataMatch.geometry);\r\n        const depth = segmentDataMatch.depth;\r\n        if (depth) {\r\n          uid += '-' + depth.join('-'); // separate feature components\r\n        }\r\n        if (!componentSegments[uid]) {\r\n          componentSegments[uid] = new Array(2);\r\n        }\r\n\r\n        if (\r\n          segmentDataMatch.geometry.getType() === 'Circle' &&\r\n          segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX\r\n        ) {\r\n          const closestVertex = closestOnSegmentData(\r\n            pixelCoordinate,\r\n            segmentDataMatch,\r\n            projection\r\n          );\r\n          if (\r\n            coordinatesEqual(closestVertex, vertex) &&\r\n            !componentSegments[uid][0]\r\n          ) {\r\n            this.dragSegments_.push([segmentDataMatch, 0]);\r\n            componentSegments[uid][0] = segmentDataMatch;\r\n          }\r\n          continue;\r\n        }\r\n\r\n        if (\r\n          coordinatesEqual(segment[0], vertex) &&\r\n          !componentSegments[uid][0]\r\n        ) {\r\n          this.dragSegments_.push([segmentDataMatch, 0]);\r\n          componentSegments[uid][0] = segmentDataMatch;\r\n          continue;\r\n        }\r\n\r\n        if (\r\n          coordinatesEqual(segment[1], vertex) &&\r\n          !componentSegments[uid][1]\r\n        ) {\r\n          if (\r\n            componentSegments[uid][0] &&\r\n            componentSegments[uid][0].index === 0\r\n          ) {\r\n            let coordinates = segmentDataMatch.geometry.getCoordinates();\r\n            switch (segmentDataMatch.geometry.getType()) {\r\n              // prevent dragging closed linestrings by the connecting node\r\n              case 'LineString':\r\n              case 'MultiLineString':\r\n                continue;\r\n              // if dragging the first vertex of a polygon, ensure the other segment\r\n              // belongs to the closing vertex of the linear ring\r\n              case 'MultiPolygon':\r\n                coordinates = coordinates[depth[1]];\r\n              /* falls through */\r\n              case 'Polygon':\r\n                if (\r\n                  segmentDataMatch.index !==\r\n                  coordinates[depth[0]].length - 2\r\n                ) {\r\n                  continue;\r\n                }\r\n                break;\r\n              default:\r\n              // pass\r\n            }\r\n          }\r\n\r\n          this.dragSegments_.push([segmentDataMatch, 1]);\r\n          componentSegments[uid][1] = segmentDataMatch;\r\n          continue;\r\n        }\r\n\r\n        if (\r\n          getUid(segment) in this.vertexSegments_ &&\r\n          !componentSegments[uid][0] &&\r\n          !componentSegments[uid][1] &&\r\n          this.insertVertexCondition_(evt)\r\n        ) {\r\n          insertVertices.push(segmentDataMatch);\r\n        }\r\n      }\r\n\r\n      if (insertVertices.length) {\r\n        this.willModifyFeatures_(evt, [insertVertices]);\r\n      }\r\n\r\n      for (let j = insertVertices.length - 1; j >= 0; --j) {\r\n        this.insertVertex_(insertVertices[j], vertex);\r\n      }\r\n    }\r\n    return !!this.vertexFeature_;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleUpEvent(evt) {\r\n    for (let i = this.dragSegments_.length - 1; i >= 0; --i) {\r\n      const segmentData = this.dragSegments_[i][0];\r\n      const geometry = segmentData.geometry;\r\n      if (geometry.getType() === 'Circle') {\r\n        // Update a circle object in the R* bush:\r\n        const coordinates = geometry.getCenter();\r\n        const centerSegmentData = segmentData.featureSegments[0];\r\n        const circumferenceSegmentData = segmentData.featureSegments[1];\r\n        centerSegmentData.segment[0] = coordinates;\r\n        centerSegmentData.segment[1] = coordinates;\r\n        circumferenceSegmentData.segment[0] = coordinates;\r\n        circumferenceSegmentData.segment[1] = coordinates;\r\n        this.rBush_.update(createExtent(coordinates), centerSegmentData);\r\n        let circleGeometry = geometry;\r\n        const userProjection = getUserProjection();\r\n        if (userProjection) {\r\n          const projection = evt.map.getView().getProjection();\r\n          circleGeometry = circleGeometry\r\n            .clone()\r\n            .transform(userProjection, projection);\r\n          circleGeometry = fromCircle(circleGeometry).transform(\r\n            projection,\r\n            userProjection\r\n          );\r\n        }\r\n        this.rBush_.update(\r\n          circleGeometry.getExtent(),\r\n          circumferenceSegmentData\r\n        );\r\n      } else {\r\n        this.rBush_.update(boundingExtent(segmentData.segment), segmentData);\r\n      }\r\n    }\r\n    if (this.featuresBeingModified_) {\r\n      this.dispatchEvent(\r\n        new ModifyEvent(\r\n          ModifyEventType.MODIFYEND,\r\n          this.featuresBeingModified_,\r\n          evt\r\n        )\r\n      );\r\n      this.featuresBeingModified_ = null;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\r\n   * @private\r\n   */\r\n  handlePointerMove_(evt) {\r\n    this.lastPixel_ = evt.pixel;\r\n    this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\r\n   * @param {import(\"../Map.js\").default} map Map.\r\n   * @param {import(\"../coordinate.js\").Coordinate} [coordinate] The pixel Coordinate.\r\n   * @private\r\n   */\r\n  handlePointerAtPixel_(pixel, map, coordinate) {\r\n    const pixelCoordinate = coordinate || map.getCoordinateFromPixel(pixel);\r\n    const projection = map.getView().getProjection();\r\n    const sortByDistance = function (a, b) {\r\n      return (\r\n        projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) -\r\n        projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection)\r\n      );\r\n    };\r\n\r\n    /** @type {Array<SegmentData>|undefined} */\r\n    let nodes;\r\n    /** @type {Point|undefined} */\r\n    let hitPointGeometry;\r\n    if (this.hitDetection_) {\r\n      const layerFilter =\r\n        typeof this.hitDetection_ === 'object'\r\n          ? (layer) => layer === this.hitDetection_\r\n          : undefined;\r\n      map.forEachFeatureAtPixel(\r\n        pixel,\r\n        (feature, layer, geometry) => {\r\n          if (geometry) {\r\n            geometry = new Point(\r\n              toUserCoordinate(geometry.getCoordinates(), projection)\r\n            );\r\n          }\r\n          const geom = geometry || feature.getGeometry();\r\n          if (\r\n            geom.getType() === 'Point' &&\r\n            feature instanceof Feature &&\r\n            this.features_.getArray().includes(feature)\r\n          ) {\r\n            hitPointGeometry = /** @type {Point} */ (geom);\r\n            const coordinate = /** @type {Point} */ (feature.getGeometry())\r\n              .getFlatCoordinates()\r\n              .slice(0, 2);\r\n            nodes = [\r\n              {\r\n                feature,\r\n                geometry: hitPointGeometry,\r\n                segment: [coordinate, coordinate],\r\n              },\r\n            ];\r\n          }\r\n          return true;\r\n        },\r\n        {layerFilter}\r\n      );\r\n    }\r\n    if (!nodes) {\r\n      const viewExtent = fromUserExtent(\r\n        createExtent(pixelCoordinate, tempExtent),\r\n        projection\r\n      );\r\n      const buffer = map.getView().getResolution() * this.pixelTolerance_;\r\n      const box = toUserExtent(\r\n        bufferExtent(viewExtent, buffer, tempExtent),\r\n        projection\r\n      );\r\n      nodes = this.rBush_.getInExtent(box);\r\n    }\r\n\r\n    if (nodes && nodes.length > 0) {\r\n      const node = nodes.sort(sortByDistance)[0];\r\n      const closestSegment = node.segment;\r\n      let vertex = closestOnSegmentData(pixelCoordinate, node, projection);\r\n      const vertexPixel = map.getPixelFromCoordinate(vertex);\r\n      let dist = coordinateDistance(pixel, vertexPixel);\r\n      if (hitPointGeometry || dist <= this.pixelTolerance_) {\r\n        /** @type {Object<string, boolean>} */\r\n        const vertexSegments = {};\r\n        vertexSegments[getUid(closestSegment)] = true;\r\n\r\n        if (!this.snapToPointer_) {\r\n          this.delta_[0] = vertex[0] - pixelCoordinate[0];\r\n          this.delta_[1] = vertex[1] - pixelCoordinate[1];\r\n        }\r\n        if (\r\n          node.geometry.getType() === 'Circle' &&\r\n          node.index === CIRCLE_CIRCUMFERENCE_INDEX\r\n        ) {\r\n          this.snappedToVertex_ = true;\r\n          this.createOrUpdateVertexFeature_(\r\n            vertex,\r\n            [node.feature],\r\n            [node.geometry]\r\n          );\r\n        } else {\r\n          const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\r\n          const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\r\n          const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\r\n          const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\r\n          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\r\n          this.snappedToVertex_ = dist <= this.pixelTolerance_;\r\n          if (this.snappedToVertex_) {\r\n            vertex =\r\n              squaredDist1 > squaredDist2\r\n                ? closestSegment[1]\r\n                : closestSegment[0];\r\n          }\r\n          this.createOrUpdateVertexFeature_(\r\n            vertex,\r\n            [node.feature],\r\n            [node.geometry]\r\n          );\r\n          const geometries = {};\r\n          geometries[getUid(node.geometry)] = true;\r\n          for (let i = 1, ii = nodes.length; i < ii; ++i) {\r\n            const segment = nodes[i].segment;\r\n            if (\r\n              (coordinatesEqual(closestSegment[0], segment[0]) &&\r\n                coordinatesEqual(closestSegment[1], segment[1])) ||\r\n              (coordinatesEqual(closestSegment[0], segment[1]) &&\r\n                coordinatesEqual(closestSegment[1], segment[0]))\r\n            ) {\r\n              const geometryUid = getUid(nodes[i].geometry);\r\n              if (!(geometryUid in geometries)) {\r\n                geometries[geometryUid] = true;\r\n                vertexSegments[getUid(segment)] = true;\r\n              }\r\n            } else {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        this.vertexSegments_ = vertexSegments;\r\n        return;\r\n      }\r\n    }\r\n    if (this.vertexFeature_) {\r\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\r\n      this.vertexFeature_ = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {SegmentData} segmentData Segment data.\r\n   * @param {import(\"../coordinate.js\").Coordinate} vertex Vertex.\r\n   * @private\r\n   */\r\n  insertVertex_(segmentData, vertex) {\r\n    const segment = segmentData.segment;\r\n    const feature = segmentData.feature;\r\n    const geometry = segmentData.geometry;\r\n    const depth = segmentData.depth;\r\n    const index = segmentData.index;\r\n    let coordinates;\r\n\r\n    while (vertex.length < geometry.getStride()) {\r\n      vertex.push(0);\r\n    }\r\n\r\n    switch (geometry.getType()) {\r\n      case 'MultiLineString':\r\n        coordinates = geometry.getCoordinates();\r\n        coordinates[depth[0]].splice(index + 1, 0, vertex);\r\n        break;\r\n      case 'Polygon':\r\n        coordinates = geometry.getCoordinates();\r\n        coordinates[depth[0]].splice(index + 1, 0, vertex);\r\n        break;\r\n      case 'MultiPolygon':\r\n        coordinates = geometry.getCoordinates();\r\n        coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);\r\n        break;\r\n      case 'LineString':\r\n        coordinates = geometry.getCoordinates();\r\n        coordinates.splice(index + 1, 0, vertex);\r\n        break;\r\n      default:\r\n        return;\r\n    }\r\n\r\n    this.setGeometryCoordinates_(geometry, coordinates);\r\n    const rTree = this.rBush_;\r\n    rTree.remove(segmentData);\r\n    this.updateSegmentIndices_(geometry, index, depth, 1);\r\n\r\n    /** @type {SegmentData} */\r\n    const newSegmentData = {\r\n      segment: [segment[0], vertex],\r\n      feature: feature,\r\n      geometry: geometry,\r\n      depth: depth,\r\n      index: index,\r\n    };\r\n\r\n    rTree.insert(boundingExtent(newSegmentData.segment), newSegmentData);\r\n    this.dragSegments_.push([newSegmentData, 1]);\r\n\r\n    /** @type {SegmentData} */\r\n    const newSegmentData2 = {\r\n      segment: [vertex, segment[1]],\r\n      feature: feature,\r\n      geometry: geometry,\r\n      depth: depth,\r\n      index: index + 1,\r\n    };\r\n\r\n    rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);\r\n    this.dragSegments_.push([newSegmentData2, 0]);\r\n    this.ignoreNextSingleClick_ = true;\r\n  }\r\n\r\n  /**\r\n   * Removes the vertex currently being pointed.\r\n   * @return {boolean} True when a vertex was removed.\r\n   * @api\r\n   */\r\n  removePoint() {\r\n    if (\r\n      this.lastPointerEvent_ &&\r\n      this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG\r\n    ) {\r\n      const evt = this.lastPointerEvent_;\r\n      this.willModifyFeatures_(evt, this.dragSegments_);\r\n      const removed = this.removeVertex_();\r\n      if (this.featuresBeingModified_) {\r\n        this.dispatchEvent(\r\n          new ModifyEvent(\r\n            ModifyEventType.MODIFYEND,\r\n            this.featuresBeingModified_,\r\n            evt\r\n          )\r\n        );\r\n      }\r\n\r\n      this.featuresBeingModified_ = null;\r\n      return removed;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Removes a vertex from all matching features.\r\n   * @return {boolean} True when a vertex was removed.\r\n   * @private\r\n   */\r\n  removeVertex_() {\r\n    const dragSegments = this.dragSegments_;\r\n    const segmentsByFeature = {};\r\n    let deleted = false;\r\n    let component, coordinates, dragSegment, geometry, i, index, left;\r\n    let newIndex, right, segmentData, uid;\r\n    for (i = dragSegments.length - 1; i >= 0; --i) {\r\n      dragSegment = dragSegments[i];\r\n      segmentData = dragSegment[0];\r\n      uid = getUid(segmentData.feature);\r\n      if (segmentData.depth) {\r\n        // separate feature components\r\n        uid += '-' + segmentData.depth.join('-');\r\n      }\r\n      if (!(uid in segmentsByFeature)) {\r\n        segmentsByFeature[uid] = {};\r\n      }\r\n      if (dragSegment[1] === 0) {\r\n        segmentsByFeature[uid].right = segmentData;\r\n        segmentsByFeature[uid].index = segmentData.index;\r\n      } else if (dragSegment[1] == 1) {\r\n        segmentsByFeature[uid].left = segmentData;\r\n        segmentsByFeature[uid].index = segmentData.index + 1;\r\n      }\r\n    }\r\n    for (uid in segmentsByFeature) {\r\n      right = segmentsByFeature[uid].right;\r\n      left = segmentsByFeature[uid].left;\r\n      index = segmentsByFeature[uid].index;\r\n      newIndex = index - 1;\r\n      if (left !== undefined) {\r\n        segmentData = left;\r\n      } else {\r\n        segmentData = right;\r\n      }\r\n      if (newIndex < 0) {\r\n        newIndex = 0;\r\n      }\r\n      geometry = segmentData.geometry;\r\n      coordinates = geometry.getCoordinates();\r\n      component = coordinates;\r\n      deleted = false;\r\n      switch (geometry.getType()) {\r\n        case 'MultiLineString':\r\n          if (coordinates[segmentData.depth[0]].length > 2) {\r\n            coordinates[segmentData.depth[0]].splice(index, 1);\r\n            deleted = true;\r\n          }\r\n          break;\r\n        case 'LineString':\r\n          if (coordinates.length > 2) {\r\n            coordinates.splice(index, 1);\r\n            deleted = true;\r\n          }\r\n          break;\r\n        case 'MultiPolygon':\r\n          component = component[segmentData.depth[1]];\r\n        /* falls through */\r\n        case 'Polygon':\r\n          component = component[segmentData.depth[0]];\r\n          if (component.length > 4) {\r\n            if (index == component.length - 1) {\r\n              index = 0;\r\n            }\r\n            component.splice(index, 1);\r\n            deleted = true;\r\n            if (index === 0) {\r\n              // close the ring again\r\n              component.pop();\r\n              component.push(component[0]);\r\n              newIndex = component.length - 1;\r\n            }\r\n          }\r\n          break;\r\n        default:\r\n        // pass\r\n      }\r\n\r\n      if (deleted) {\r\n        this.setGeometryCoordinates_(geometry, coordinates);\r\n        const segments = [];\r\n        if (left !== undefined) {\r\n          this.rBush_.remove(left);\r\n          segments.push(left.segment[0]);\r\n        }\r\n        if (right !== undefined) {\r\n          this.rBush_.remove(right);\r\n          segments.push(right.segment[1]);\r\n        }\r\n        if (left !== undefined && right !== undefined) {\r\n          /** @type {SegmentData} */\r\n          const newSegmentData = {\r\n            depth: segmentData.depth,\r\n            feature: segmentData.feature,\r\n            geometry: segmentData.geometry,\r\n            index: newIndex,\r\n            segment: segments,\r\n          };\r\n\r\n          this.rBush_.insert(\r\n            boundingExtent(newSegmentData.segment),\r\n            newSegmentData\r\n          );\r\n        }\r\n        this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);\r\n        if (this.vertexFeature_) {\r\n          this.overlay_.getSource().removeFeature(this.vertexFeature_);\r\n          this.vertexFeature_ = null;\r\n        }\r\n        dragSegments.length = 0;\r\n      }\r\n    }\r\n    return deleted;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\r\n   * @param {Array} coordinates Coordinates.\r\n   * @private\r\n   */\r\n  setGeometryCoordinates_(geometry, coordinates) {\r\n    this.changingFeature_ = true;\r\n    geometry.setCoordinates(coordinates);\r\n    this.changingFeature_ = false;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\r\n   * @param {number} index Index.\r\n   * @param {Array<number>|undefined} depth Depth.\r\n   * @param {number} delta Delta (1 or -1).\r\n   * @private\r\n   */\r\n  updateSegmentIndices_(geometry, index, depth, delta) {\r\n    this.rBush_.forEachInExtent(\r\n      geometry.getExtent(),\r\n      function (segmentDataMatch) {\r\n        if (\r\n          segmentDataMatch.geometry === geometry &&\r\n          (depth === undefined ||\r\n            segmentDataMatch.depth === undefined ||\r\n            equals(segmentDataMatch.depth, depth)) &&\r\n          segmentDataMatch.index > index\r\n        ) {\r\n          segmentDataMatch.index += delta;\r\n        }\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @param {SegmentData} a The first segment data.\r\n * @param {SegmentData} b The second segment data.\r\n * @return {number} The difference in indexes.\r\n */\r\nfunction compareIndexes(a, b) {\r\n  return a.index - b.index;\r\n}\r\n\r\n/**\r\n * Returns the distance from a point to a line segment.\r\n *\r\n * @param {import(\"../coordinate.js\").Coordinate} pointCoordinates The coordinates of the point from\r\n *        which to calculate the distance.\r\n * @param {SegmentData} segmentData The object describing the line\r\n *        segment we are calculating the distance to.\r\n * @param {import(\"../proj/Projection.js\").default} projection The view projection.\r\n * @return {number} The square of the distance between a point and a line segment.\r\n */\r\nfunction projectedDistanceToSegmentDataSquared(\r\n  pointCoordinates,\r\n  segmentData,\r\n  projection\r\n) {\r\n  const geometry = segmentData.geometry;\r\n\r\n  if (geometry.getType() === 'Circle') {\r\n    let circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\r\n      geometry\r\n    );\r\n\r\n    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {\r\n      const userProjection = getUserProjection();\r\n      if (userProjection) {\r\n        circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\r\n          circleGeometry.clone().transform(userProjection, projection)\r\n        );\r\n      }\r\n      const distanceToCenterSquared = squaredCoordinateDistance(\r\n        circleGeometry.getCenter(),\r\n        fromUserCoordinate(pointCoordinates, projection)\r\n      );\r\n      const distanceToCircumference =\r\n        Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();\r\n      return distanceToCircumference * distanceToCircumference;\r\n    }\r\n  }\r\n\r\n  const coordinate = fromUserCoordinate(pointCoordinates, projection);\r\n  tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);\r\n  tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);\r\n  return squaredDistanceToSegment(coordinate, tempSegment);\r\n}\r\n\r\n/**\r\n * Returns the point closest to a given line segment.\r\n *\r\n * @param {import(\"../coordinate.js\").Coordinate} pointCoordinates The point to which a closest point\r\n *        should be found.\r\n * @param {SegmentData} segmentData The object describing the line\r\n *        segment which should contain the closest point.\r\n * @param {import(\"../proj/Projection.js\").default} projection The view projection.\r\n * @return {import(\"../coordinate.js\").Coordinate} The point closest to the specified line segment.\r\n */\r\nfunction closestOnSegmentData(pointCoordinates, segmentData, projection) {\r\n  const geometry = segmentData.geometry;\r\n\r\n  if (\r\n    geometry.getType() === 'Circle' &&\r\n    segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX\r\n  ) {\r\n    let circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\r\n      geometry\r\n    );\r\n    const userProjection = getUserProjection();\r\n    if (userProjection) {\r\n      circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\r\n        circleGeometry.clone().transform(userProjection, projection)\r\n      );\r\n    }\r\n    return toUserCoordinate(\r\n      circleGeometry.getClosestPoint(\r\n        fromUserCoordinate(pointCoordinates, projection)\r\n      ),\r\n      projection\r\n    );\r\n  }\r\n  const coordinate = fromUserCoordinate(pointCoordinates, projection);\r\n  tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);\r\n  tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);\r\n  return toUserCoordinate(\r\n    closestOnSegment(coordinate, tempSegment),\r\n    projection\r\n  );\r\n}\r\n\r\n/**\r\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\r\n */\r\nfunction getDefaultStyleFunction() {\r\n  const style = createEditingStyle();\r\n  return function (feature, resolution) {\r\n    return style['Point'];\r\n  };\r\n}\r\n\r\nexport default Modify;\r\n", "/**\r\n * @module ol/interaction/Select\r\n */\r\nimport Collection from '../Collection.js';\r\nimport CollectionEventType from '../CollectionEventType.js';\r\nimport Event from '../events/Event.js';\r\nimport Feature from '../Feature.js';\r\nimport Interaction from './Interaction.js';\r\nimport VectorLayer from '../layer/Vector.js';\r\nimport {TRUE} from '../functions.js';\r\nimport {clear} from '../obj.js';\r\nimport {createEditingStyle} from '../style/Style.js';\r\nimport {extend} from '../array.js';\r\nimport {getUid} from '../util.js';\r\nimport {never, shiftKeyOnly, singleClick} from '../events/condition.js';\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nconst SelectEventType = {\r\n  /**\r\n   * Triggered when feature(s) has been (de)selected.\r\n   * @event SelectEvent#select\r\n   * @api\r\n   */\r\n  SELECT: 'select',\r\n};\r\n\r\n/**\r\n * A function that takes an {@link module:ol/Feature~Feature} and returns `true` if the feature may be\r\n * selected or `false` otherwise.\r\n * @typedef {function(import(\"../Feature.js\").default, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../events/condition.js\").Condition} [addCondition] A function\r\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event should be handled.\r\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\r\n * want to use different events for add and remove instead of `toggle`.\r\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\r\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event should be handled. This is the event\r\n * for the selected features as a whole. By default, this is\r\n * {@link module:ol/events/condition.singleClick}. Clicking on a feature selects that\r\n * feature and removes any that were in the selection. Clicking outside any\r\n * feature removes all from the selection.\r\n * See `toggle`, `add`, `remove` options for adding/removing extra features to/\r\n * from the selection.\r\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers]\r\n * A list of layers from which features should be selected. Alternatively, a\r\n * filter function can be provided. The function will be called for each layer\r\n * in the map and should return `true` for layers that you want to be\r\n * selectable. If the option is absent, all visible layers will be considered\r\n * selectable.\r\n * @property {import(\"../style/Style.js\").StyleLike|null} [style]\r\n * Style for the selected features. By default the default edit style is used\r\n * (see {@link module:ol/style/Style~Style}). Set to `null` if this interaction should not apply\r\n * any style changes for selected features.\r\n * If set to a falsey value, the selected feature's style will not change.\r\n * @property {import(\"../events/condition.js\").Condition} [removeCondition] A function\r\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event should be handled.\r\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\r\n * want to use different events for add and remove instead of `toggle`.\r\n * @property {import(\"../events/condition.js\").Condition} [toggleCondition] A function\r\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event should be handled. This is in addition\r\n * to the `condition` event. By default,\r\n * {@link module:ol/events/condition.shiftKeyOnly}, i.e. pressing `shift` as\r\n * well as the `condition` event, adds that feature to the current selection if\r\n * it is not currently selected, and removes it if it is. See `add` and `remove`\r\n * if you want to use different events instead of a toggle.\r\n * @property {boolean} [multi=false] A boolean that determines if the default\r\n * behaviour should select only single features or all (overlapping) features at\r\n * the clicked map position. The default of `false` means single select.\r\n * @property {Collection<Feature>} [features]\r\n * Collection where the interaction will place selected features. Optional. If\r\n * not set the interaction will create a collection. In any case the collection\r\n * used by the interaction is returned by\r\n * {@link module:ol/interaction/Select~Select#getFeatures}.\r\n * @property {FilterFunction} [filter] A function\r\n * that takes an {@link module:ol/Feature~Feature} and an\r\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\r\n * selected or `false` otherwise.\r\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside\r\n * the radius around the given position will be checked for features.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of\r\n * this type.\r\n */\r\nexport class SelectEvent extends Event {\r\n  /**\r\n   * @param {SelectEventType} type The event type.\r\n   * @param {Array<import(\"../Feature.js\").default>} selected Selected features.\r\n   * @param {Array<import(\"../Feature.js\").default>} deselected Deselected features.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Associated\r\n   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\r\n   */\r\n  constructor(type, selected, deselected, mapBrowserEvent) {\r\n    super(type);\r\n\r\n    /**\r\n     * Selected features array.\r\n     * @type {Array<import(\"../Feature.js\").default>}\r\n     * @api\r\n     */\r\n    this.selected = selected;\r\n\r\n    /**\r\n     * Deselected features array.\r\n     * @type {Array<import(\"../Feature.js\").default>}\r\n     * @api\r\n     */\r\n    this.deselected = deselected;\r\n\r\n    /**\r\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\r\n     * @type {import(\"../MapBrowserEvent.js\").default}\r\n     * @api\r\n     */\r\n    this.mapBrowserEvent = mapBrowserEvent;\r\n  }\r\n}\r\n\r\n/**\r\n * Original feature styles to reset to when features are no longer selected.\r\n * @type {Object<number, import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction>}\r\n */\r\nconst originalFeatureStyles = {};\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\r\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<'select', SelectEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\r\n *     'change:active'|'select', Return>} SelectOnSignature\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Interaction for selecting vector features. By default, selected features are\r\n * styled differently, so this interaction can be used for visual highlighting,\r\n * as well as selecting features for other actions, such as modification or\r\n * output. There are three ways of controlling which features are selected:\r\n * using the browser event as defined by the `condition` and optionally the\r\n * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a\r\n * further feature filter using the `filter` option.\r\n *\r\n * @fires SelectEvent\r\n * @api\r\n */\r\nclass Select extends Interaction {\r\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    /***\r\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {SelectOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    options = options ? options : {};\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.boundAddFeature_ = this.addFeature_.bind(this);\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.boundRemoveFeature_ = this.removeFeature_.bind(this);\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\r\n    this.condition_ = options.condition ? options.condition : singleClick;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\r\n    this.addCondition_ = options.addCondition ? options.addCondition : never;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\r\n    this.removeCondition_ = options.removeCondition\r\n      ? options.removeCondition\r\n      : never;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\r\n    this.toggleCondition_ = options.toggleCondition\r\n      ? options.toggleCondition\r\n      : shiftKeyOnly;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.multi_ = options.multi ? options.multi : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {FilterFunction}\r\n     */\r\n    this.filter_ = options.filter ? options.filter : TRUE;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction|null}\r\n     */\r\n    this.style_ =\r\n      options.style !== undefined ? options.style : getDefaultStyleFunction();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Collection<Feature>}\r\n     */\r\n    this.features_ = options.features || new Collection();\r\n\r\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\r\n    let layerFilter;\r\n    if (options.layers) {\r\n      if (typeof options.layers === 'function') {\r\n        layerFilter = options.layers;\r\n      } else {\r\n        const layers = options.layers;\r\n        layerFilter = function (layer) {\r\n          return layers.includes(layer);\r\n        };\r\n      }\r\n    } else {\r\n      layerFilter = TRUE;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\r\n     */\r\n    this.layerFilter_ = layerFilter;\r\n\r\n    /**\r\n     * An association between selected feature (key)\r\n     * and layer (value)\r\n     * @private\r\n     * @type {Object<string, import(\"../layer/Layer.js\").default>}\r\n     */\r\n    this.featureLayerAssociation_ = {};\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Feature.js\").default} feature Feature.\r\n   * @param {import(\"../layer/Layer.js\").default} layer Layer.\r\n   * @private\r\n   */\r\n  addFeatureLayerAssociation_(feature, layer) {\r\n    this.featureLayerAssociation_[getUid(feature)] = layer;\r\n  }\r\n\r\n  /**\r\n   * Get the selected features.\r\n   * @return {Collection<Feature>} Features collection.\r\n   * @api\r\n   */\r\n  getFeatures() {\r\n    return this.features_;\r\n  }\r\n\r\n  /**\r\n   * Returns the Hit-detection tolerance.\r\n   * @return {number} Hit tolerance in pixels.\r\n   * @api\r\n   */\r\n  getHitTolerance() {\r\n    return this.hitTolerance_;\r\n  }\r\n\r\n  /**\r\n   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of\r\n   * a selected feature.\r\n   * @param {import(\"../Feature.js\").default} feature Feature\r\n   * @return {import('../layer/Vector.js').default} Layer.\r\n   * @api\r\n   */\r\n  getLayer(feature) {\r\n    return /** @type {import('../layer/Vector.js').default} */ (\r\n      this.featureLayerAssociation_[getUid(feature)]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Hit-detection tolerance. Pixels inside the radius around the given position\r\n   * will be checked for features.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @api\r\n   */\r\n  setHitTolerance(hitTolerance) {\r\n    this.hitTolerance_ = hitTolerance;\r\n  }\r\n\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {import(\"../Map.js\").default|null} map Map.\r\n   * @api\r\n   */\r\n  setMap(map) {\r\n    const currentMap = this.getMap();\r\n    if (currentMap && this.style_) {\r\n      this.features_.forEach(this.restorePreviousStyle_.bind(this));\r\n    }\r\n    super.setMap(map);\r\n    if (map) {\r\n      this.features_.addEventListener(\r\n        CollectionEventType.ADD,\r\n        this.boundAddFeature_\r\n      );\r\n      this.features_.addEventListener(\r\n        CollectionEventType.REMOVE,\r\n        this.boundRemoveFeature_\r\n      );\r\n\r\n      if (this.style_) {\r\n        this.features_.forEach(this.applySelectedStyle_.bind(this));\r\n      }\r\n    } else {\r\n      this.features_.removeEventListener(\r\n        CollectionEventType.ADD,\r\n        this.boundAddFeature_\r\n      );\r\n      this.features_.removeEventListener(\r\n        CollectionEventType.REMOVE,\r\n        this.boundRemoveFeature_\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\r\n   * @private\r\n   */\r\n  addFeature_(evt) {\r\n    const feature = evt.element;\r\n    if (this.style_) {\r\n      this.applySelectedStyle_(feature);\r\n    }\r\n    if (!this.getLayer(feature)) {\r\n      const layer = /** @type {VectorLayer} */ (\r\n        this.getMap()\r\n          .getAllLayers()\r\n          .find(function (layer) {\r\n            if (\r\n              layer instanceof VectorLayer &&\r\n              layer.getSource() &&\r\n              layer.getSource().hasFeature(feature)\r\n            ) {\r\n              return layer;\r\n            }\r\n          })\r\n      );\r\n      if (layer) {\r\n        this.addFeatureLayerAssociation_(feature, layer);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\r\n   * @private\r\n   */\r\n  removeFeature_(evt) {\r\n    if (this.style_) {\r\n      this.restorePreviousStyle_(evt.element);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"../style/Style.js\").StyleLike|null} Select style.\r\n   */\r\n  getStyle() {\r\n    return this.style_;\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature\r\n   * @private\r\n   */\r\n  applySelectedStyle_(feature) {\r\n    const key = getUid(feature);\r\n    if (!(key in originalFeatureStyles)) {\r\n      originalFeatureStyles[key] = feature.getStyle();\r\n    }\r\n    feature.setStyle(this.style_);\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature\r\n   * @private\r\n   */\r\n  restorePreviousStyle_(feature) {\r\n    const interactions = this.getMap().getInteractions().getArray();\r\n    for (let i = interactions.length - 1; i >= 0; --i) {\r\n      const interaction = interactions[i];\r\n      if (\r\n        interaction !== this &&\r\n        interaction instanceof Select &&\r\n        interaction.getStyle() &&\r\n        interaction.getFeatures().getArray().lastIndexOf(feature) !== -1\r\n      ) {\r\n        feature.setStyle(interaction.getStyle());\r\n        return;\r\n      }\r\n    }\r\n\r\n    const key = getUid(feature);\r\n    feature.setStyle(originalFeatureStyles[key]);\r\n    delete originalFeatureStyles[key];\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature.\r\n   * @private\r\n   */\r\n  removeFeatureLayerAssociation_(feature) {\r\n    delete this.featureLayerAssociation_[getUid(feature)];\r\n  }\r\n\r\n  /**\r\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the\r\n   * selected state of features.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n   * @return {boolean} `false` to stop event propagation.\r\n   */\r\n  handleEvent(mapBrowserEvent) {\r\n    if (!this.condition_(mapBrowserEvent)) {\r\n      return true;\r\n    }\r\n    const add = this.addCondition_(mapBrowserEvent);\r\n    const remove = this.removeCondition_(mapBrowserEvent);\r\n    const toggle = this.toggleCondition_(mapBrowserEvent);\r\n    const set = !add && !remove && !toggle;\r\n    const map = mapBrowserEvent.map;\r\n    const features = this.getFeatures();\r\n\r\n    /**\r\n     * @type {Array<Feature>}\r\n     */\r\n    const deselected = [];\r\n\r\n    /**\r\n     * @type {Array<Feature>}\r\n     */\r\n    const selected = [];\r\n\r\n    if (set) {\r\n      // Replace the currently selected feature(s) with the feature(s) at the\r\n      // pixel, or clear the selected feature(s) if there is no feature at\r\n      // the pixel.\r\n      clear(this.featureLayerAssociation_);\r\n      map.forEachFeatureAtPixel(\r\n        mapBrowserEvent.pixel,\r\n        /**\r\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\r\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\r\n         * @return {boolean|undefined} Continue to iterate over the features.\r\n         */\r\n        (feature, layer) => {\r\n          if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\r\n            return;\r\n          }\r\n          this.addFeatureLayerAssociation_(feature, layer);\r\n          selected.push(feature);\r\n          return !this.multi_;\r\n        },\r\n        {\r\n          layerFilter: this.layerFilter_,\r\n          hitTolerance: this.hitTolerance_,\r\n        }\r\n      );\r\n      for (let i = features.getLength() - 1; i >= 0; --i) {\r\n        const feature = features.item(i);\r\n        const index = selected.indexOf(feature);\r\n        if (index > -1) {\r\n          // feature is already selected\r\n          selected.splice(index, 1);\r\n        } else {\r\n          features.remove(feature);\r\n          deselected.push(feature);\r\n        }\r\n      }\r\n      if (selected.length !== 0) {\r\n        features.extend(selected);\r\n      }\r\n    } else {\r\n      // Modify the currently selected feature(s).\r\n      map.forEachFeatureAtPixel(\r\n        mapBrowserEvent.pixel,\r\n        /**\r\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\r\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\r\n         * @return {boolean|undefined} Continue to iterate over the features.\r\n         */\r\n        (feature, layer) => {\r\n          if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\r\n            return;\r\n          }\r\n          if ((add || toggle) && !features.getArray().includes(feature)) {\r\n            this.addFeatureLayerAssociation_(feature, layer);\r\n            selected.push(feature);\r\n          } else if (\r\n            (remove || toggle) &&\r\n            features.getArray().includes(feature)\r\n          ) {\r\n            deselected.push(feature);\r\n            this.removeFeatureLayerAssociation_(feature);\r\n          }\r\n          return !this.multi_;\r\n        },\r\n        {\r\n          layerFilter: this.layerFilter_,\r\n          hitTolerance: this.hitTolerance_,\r\n        }\r\n      );\r\n      for (let j = deselected.length - 1; j >= 0; --j) {\r\n        features.remove(deselected[j]);\r\n      }\r\n      features.extend(selected);\r\n    }\r\n    if (selected.length > 0 || deselected.length > 0) {\r\n      this.dispatchEvent(\r\n        new SelectEvent(\r\n          SelectEventType.SELECT,\r\n          selected,\r\n          deselected,\r\n          mapBrowserEvent\r\n        )\r\n      );\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\r\n */\r\nfunction getDefaultStyleFunction() {\r\n  const styles = createEditingStyle();\r\n  extend(styles['Polygon'], styles['LineString']);\r\n  extend(styles['GeometryCollection'], styles['LineString']);\r\n\r\n  return function (feature) {\r\n    if (!feature.getGeometry()) {\r\n      return null;\r\n    }\r\n    return styles[feature.getGeometry().getType()];\r\n  };\r\n}\r\n\r\nexport default Select;\r\n", "/**\r\n * @module ol/interaction/Snap\r\n */\r\nimport CollectionEventType from '../CollectionEventType.js';\r\nimport EventType from '../events/EventType.js';\r\nimport PointerInteraction from './Pointer.js';\r\nimport RBush from '../structs/RBush.js';\r\nimport VectorEventType from '../source/VectorEventType.js';\r\nimport {FALSE, TRUE} from '../functions.js';\r\nimport {boundingExtent, buffer, createEmpty} from '../extent.js';\r\nimport {\r\n  closestOnCircle,\r\n  closestOnSegment,\r\n  squaredDistance,\r\n} from '../coordinate.js';\r\nimport {fromCircle} from '../geom/Polygon.js';\r\nimport {\r\n  fromUserCoordinate,\r\n  getUserProjection,\r\n  toUserCoordinate,\r\n  toUserExtent,\r\n} from '../proj.js';\r\nimport {getUid} from '../util.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\n\r\n/**\r\n * @typedef {Object} Result\r\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\r\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\r\n */\r\n\r\n/**\r\n * @typedef {Object} SegmentData\r\n * @property {import(\"../Feature.js\").default} feature Feature.\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\r\n * @property {boolean} [edge=true] Snap to edges.\r\n * @property {boolean} [vertex=true] Snap to vertices.\r\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\r\n * vertex for snapping.\r\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\r\n */\r\n\r\n/**\r\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\r\n * @return {import(\"../Feature.js\").default|null} Feature.\r\n */\r\nfunction getFeatureFromEvent(evt) {\r\n  if (\r\n    /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature\r\n  ) {\r\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt)\r\n      .feature;\r\n  }\r\n  if (\r\n    /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\r\n      evt\r\n    ).element\r\n  ) {\r\n    return /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\r\n      evt\r\n    ).element;\r\n  }\r\n  return null;\r\n}\r\n\r\nconst tempSegment = [];\r\n\r\n/**\r\n * @classdesc\r\n * Handles snapping of vector features while modifying or drawing them.  The\r\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\r\n * Any interaction object that allows the user to interact\r\n * with the features using the mouse can benefit from the snapping, as long\r\n * as it is added before.\r\n *\r\n * The snap interaction modifies map browser event `coordinate` and `pixel`\r\n * properties to force the snap to occur to any interaction that them.\r\n *\r\n * Example:\r\n *\r\n *     import Snap from 'ol/interaction/Snap.js';\r\n *\r\n *     const snap = new Snap({\r\n *       source: source\r\n *     });\r\n *\r\n *     map.addInteraction(snap);\r\n *\r\n * @api\r\n */\r\nclass Snap extends PointerInteraction {\r\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? options : {};\r\n\r\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\r\n      options\r\n    );\r\n\r\n    if (!pointerOptions.handleDownEvent) {\r\n      pointerOptions.handleDownEvent = TRUE;\r\n    }\r\n\r\n    if (!pointerOptions.stopDown) {\r\n      pointerOptions.stopDown = FALSE;\r\n    }\r\n\r\n    super(pointerOptions);\r\n\r\n    /**\r\n     * @type {import(\"../source/Vector.js\").default|null}\r\n     * @private\r\n     */\r\n    this.source_ = options.source ? options.source : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.edge_ = options.edge !== undefined ? options.edge : true;\r\n\r\n    /**\r\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\r\n     * @private\r\n     */\r\n    this.features_ = options.features ? options.features : null;\r\n\r\n    /**\r\n     * @type {Array<import(\"../events.js\").EventsKey>}\r\n     * @private\r\n     */\r\n    this.featuresListenerKeys_ = [];\r\n\r\n    /**\r\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\r\n     * @private\r\n     */\r\n    this.featureChangeListenerKeys_ = {};\r\n\r\n    /**\r\n     * Extents are preserved so indexed segment can be quickly removed\r\n     * when its feature geometry changes\r\n     * @type {Object<string, import(\"../extent.js\").Extent>}\r\n     * @private\r\n     */\r\n    this.indexedFeaturesExtents_ = {};\r\n\r\n    /**\r\n     * If a feature geometry changes while a pointer drag|move event occurs, the\r\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\r\n     * event fired.\r\n     * @type {!Object<string, import(\"../Feature.js\").default>}\r\n     * @private\r\n     */\r\n    this.pendingFeatures_ = {};\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.pixelTolerance_ =\r\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\r\n\r\n    /**\r\n     * Segment RTree for each layer\r\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\r\n     * @private\r\n     */\r\n    this.rBush_ = new RBush();\r\n\r\n    /**\r\n     * @const\r\n     * @private\r\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\r\n     */\r\n    this.GEOMETRY_SEGMENTERS_ = {\r\n      'Point': this.segmentPointGeometry_.bind(this),\r\n      'LineString': this.segmentLineStringGeometry_.bind(this),\r\n      'LinearRing': this.segmentLineStringGeometry_.bind(this),\r\n      'Polygon': this.segmentPolygonGeometry_.bind(this),\r\n      'MultiPoint': this.segmentMultiPointGeometry_.bind(this),\r\n      'MultiLineString': this.segmentMultiLineStringGeometry_.bind(this),\r\n      'MultiPolygon': this.segmentMultiPolygonGeometry_.bind(this),\r\n      'GeometryCollection': this.segmentGeometryCollectionGeometry_.bind(this),\r\n      'Circle': this.segmentCircleGeometry_.bind(this),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Add a feature to the collection of features that we may snap to.\r\n   * @param {import(\"../Feature.js\").default} feature Feature.\r\n   * @param {boolean} [register] Whether to listen to the feature change or not\r\n   *     Defaults to `true`.\r\n   * @api\r\n   */\r\n  addFeature(feature, register) {\r\n    register = register !== undefined ? register : true;\r\n    const feature_uid = getUid(feature);\r\n    const geometry = feature.getGeometry();\r\n    if (geometry) {\r\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\r\n      if (segmenter) {\r\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(\r\n          createEmpty()\r\n        );\r\n        const segments =\r\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ ([]);\r\n        segmenter(segments, geometry);\r\n        if (segments.length === 1) {\r\n          this.rBush_.insert(boundingExtent(segments[0]), {\r\n            feature: feature,\r\n            segment: segments[0],\r\n          });\r\n        } else if (segments.length > 1) {\r\n          const extents = segments.map((s) => boundingExtent(s));\r\n          const segmentsData = segments.map((segment) => ({\r\n            feature: feature,\r\n            segment: segment,\r\n          }));\r\n          this.rBush_.load(extents, segmentsData);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (register) {\r\n      this.featureChangeListenerKeys_[feature_uid] = listen(\r\n        feature,\r\n        EventType.CHANGE,\r\n        this.handleFeatureChange_,\r\n        this\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\r\n   * @private\r\n   */\r\n  getFeatures_() {\r\n    /** @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} */\r\n    let features;\r\n    if (this.features_) {\r\n      features = this.features_;\r\n    } else if (this.source_) {\r\n      features = this.source_.getFeatures();\r\n    }\r\n    return features;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\r\n   * @return {boolean} `false` to stop event propagation.\r\n   */\r\n  handleEvent(evt) {\r\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\r\n    if (result) {\r\n      evt.coordinate = result.vertex.slice(0, 2);\r\n      evt.pixel = result.vertexPixel;\r\n    }\r\n    return super.handleEvent(evt);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\r\n   * @private\r\n   */\r\n  handleFeatureAdd_(evt) {\r\n    const feature = getFeatureFromEvent(evt);\r\n    if (feature) {\r\n      this.addFeature(feature);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\r\n   * @private\r\n   */\r\n  handleFeatureRemove_(evt) {\r\n    const feature = getFeatureFromEvent(evt);\r\n    if (feature) {\r\n      this.removeFeature(feature);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../events/Event.js\").default} evt Event.\r\n   * @private\r\n   */\r\n  handleFeatureChange_(evt) {\r\n    const feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\r\n    if (this.handlingDownUpSequence) {\r\n      const uid = getUid(feature);\r\n      if (!(uid in this.pendingFeatures_)) {\r\n        this.pendingFeatures_[uid] = feature;\r\n      }\r\n    } else {\r\n      this.updateFeature_(feature);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleUpEvent(evt) {\r\n    const featuresToUpdate = Object.values(this.pendingFeatures_);\r\n    if (featuresToUpdate.length) {\r\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\r\n      this.pendingFeatures_ = {};\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Remove a feature from the collection of features that we may snap to.\r\n   * @param {import(\"../Feature.js\").default} feature Feature\r\n   * @param {boolean} [unlisten] Whether to unlisten to the feature change\r\n   *     or not. Defaults to `true`.\r\n   * @api\r\n   */\r\n  removeFeature(feature, unlisten) {\r\n    const unregister = unlisten !== undefined ? unlisten : true;\r\n    const feature_uid = getUid(feature);\r\n    const extent = this.indexedFeaturesExtents_[feature_uid];\r\n    if (extent) {\r\n      const rBush = this.rBush_;\r\n      const nodesToRemove = [];\r\n      rBush.forEachInExtent(extent, function (node) {\r\n        if (feature === node.feature) {\r\n          nodesToRemove.push(node);\r\n        }\r\n      });\r\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\r\n        rBush.remove(nodesToRemove[i]);\r\n      }\r\n    }\r\n\r\n    if (unregister) {\r\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\r\n      delete this.featureChangeListenerKeys_[feature_uid];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove the interaction from its current map and attach it to the new map.\r\n   * Subclasses may set up event handlers to get notified about changes to\r\n   * the map here.\r\n   * @param {import(\"../Map.js\").default} map Map.\r\n   */\r\n  setMap(map) {\r\n    const currentMap = this.getMap();\r\n    const keys = this.featuresListenerKeys_;\r\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */ (\r\n      this.getFeatures_()\r\n    );\r\n\r\n    if (currentMap) {\r\n      keys.forEach(unlistenByKey);\r\n      keys.length = 0;\r\n      this.rBush_.clear();\r\n      Object.values(this.featureChangeListenerKeys_).forEach(unlistenByKey);\r\n      this.featureChangeListenerKeys_ = {};\r\n    }\r\n    super.setMap(map);\r\n\r\n    if (map) {\r\n      if (this.features_) {\r\n        keys.push(\r\n          listen(\r\n            this.features_,\r\n            CollectionEventType.ADD,\r\n            this.handleFeatureAdd_,\r\n            this\r\n          ),\r\n          listen(\r\n            this.features_,\r\n            CollectionEventType.REMOVE,\r\n            this.handleFeatureRemove_,\r\n            this\r\n          )\r\n        );\r\n      } else if (this.source_) {\r\n        keys.push(\r\n          listen(\r\n            this.source_,\r\n            VectorEventType.ADDFEATURE,\r\n            this.handleFeatureAdd_,\r\n            this\r\n          ),\r\n          listen(\r\n            this.source_,\r\n            VectorEventType.REMOVEFEATURE,\r\n            this.handleFeatureRemove_,\r\n            this\r\n          )\r\n        );\r\n      }\r\n      features.forEach((feature) => this.addFeature(feature));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\r\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\r\n   * @param {import(\"../Map.js\").default} map Map.\r\n   * @return {Result|null} Snap result\r\n   */\r\n  snapTo(pixel, pixelCoordinate, map) {\r\n    const projection = map.getView().getProjection();\r\n    const projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\r\n\r\n    const box = toUserExtent(\r\n      buffer(\r\n        boundingExtent([projectedCoordinate]),\r\n        map.getView().getResolution() * this.pixelTolerance_\r\n      ),\r\n      projection\r\n    );\r\n\r\n    const segments = this.rBush_.getInExtent(box);\r\n\r\n    const segmentsLength = segments.length;\r\n    if (segmentsLength === 0) {\r\n      return null;\r\n    }\r\n\r\n    let closestVertex;\r\n    let minSquaredDistance = Infinity;\r\n\r\n    const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\r\n    const getResult = () => {\r\n      if (closestVertex) {\r\n        const vertexPixel = map.getPixelFromCoordinate(closestVertex);\r\n        const squaredPixelDistance = squaredDistance(pixel, vertexPixel);\r\n        if (squaredPixelDistance <= squaredPixelTolerance) {\r\n          return {\r\n            vertex: closestVertex,\r\n            vertexPixel: [\r\n              Math.round(vertexPixel[0]),\r\n              Math.round(vertexPixel[1]),\r\n            ],\r\n          };\r\n        }\r\n      }\r\n      return null;\r\n    };\r\n\r\n    if (this.vertex_) {\r\n      for (let i = 0; i < segmentsLength; ++i) {\r\n        const segmentData = segments[i];\r\n        if (segmentData.feature.getGeometry().getType() !== 'Circle') {\r\n          segmentData.segment.forEach((vertex) => {\r\n            const tempVertexCoord = fromUserCoordinate(vertex, projection);\r\n            const delta = squaredDistance(projectedCoordinate, tempVertexCoord);\r\n            if (delta < minSquaredDistance) {\r\n              closestVertex = vertex;\r\n              minSquaredDistance = delta;\r\n            }\r\n          });\r\n        }\r\n      }\r\n      const result = getResult();\r\n      if (result) {\r\n        return result;\r\n      }\r\n    }\r\n\r\n    if (this.edge_) {\r\n      for (let i = 0; i < segmentsLength; ++i) {\r\n        let vertex = null;\r\n        const segmentData = segments[i];\r\n        if (segmentData.feature.getGeometry().getType() === 'Circle') {\r\n          let circleGeometry = segmentData.feature.getGeometry();\r\n          const userProjection = getUserProjection();\r\n          if (userProjection) {\r\n            circleGeometry = circleGeometry\r\n              .clone()\r\n              .transform(userProjection, projection);\r\n          }\r\n          vertex = closestOnCircle(\r\n            projectedCoordinate,\r\n            /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry)\r\n          );\r\n        } else {\r\n          const [segmentStart, segmentEnd] = segmentData.segment;\r\n          // points have only one coordinate\r\n          if (segmentEnd) {\r\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\r\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\r\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\r\n          }\r\n        }\r\n        if (vertex) {\r\n          const delta = squaredDistance(projectedCoordinate, vertex);\r\n          if (delta < minSquaredDistance) {\r\n            closestVertex = toUserCoordinate(vertex, projection);\r\n            minSquaredDistance = delta;\r\n          }\r\n        }\r\n      }\r\n\r\n      const result = getResult();\r\n      if (result) {\r\n        return result;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Feature.js\").default} feature Feature\r\n   * @private\r\n   */\r\n  updateFeature_(feature) {\r\n    this.removeFeature(feature, false);\r\n    this.addFeature(feature, false);\r\n  }\r\n\r\n  /**\r\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\r\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  segmentCircleGeometry_(segments, geometry) {\r\n    const projection = this.getMap().getView().getProjection();\r\n    let circleGeometry = geometry;\r\n    const userProjection = getUserProjection();\r\n    if (userProjection) {\r\n      circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\r\n        circleGeometry.clone().transform(userProjection, projection)\r\n      );\r\n    }\r\n    const polygon = fromCircle(circleGeometry);\r\n    if (userProjection) {\r\n      polygon.transform(projection, userProjection);\r\n    }\r\n    const coordinates = polygon.getCoordinates()[0];\r\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\r\n      segments.push(coordinates.slice(i, i + 2));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\r\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  segmentGeometryCollectionGeometry_(segments, geometry) {\r\n    const geometries = geometry.getGeometriesArray();\r\n    for (let i = 0; i < geometries.length; ++i) {\r\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\r\n      if (segmenter) {\r\n        segmenter(segments, geometries[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\r\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  segmentLineStringGeometry_(segments, geometry) {\r\n    const coordinates = geometry.getCoordinates();\r\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\r\n      segments.push(coordinates.slice(i, i + 2));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\r\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  segmentMultiLineStringGeometry_(segments, geometry) {\r\n    const lines = geometry.getCoordinates();\r\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\r\n      const coordinates = lines[j];\r\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\r\n        segments.push(coordinates.slice(i, i + 2));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\r\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  segmentMultiPointGeometry_(segments, geometry) {\r\n    geometry.getCoordinates().forEach((point) => {\r\n      segments.push([point]);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\r\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  segmentMultiPolygonGeometry_(segments, geometry) {\r\n    const polygons = geometry.getCoordinates();\r\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\r\n      const rings = polygons[k];\r\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\r\n        const coordinates = rings[j];\r\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\r\n          segments.push(coordinates.slice(i, i + 2));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\r\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  segmentPointGeometry_(segments, geometry) {\r\n    segments.push([geometry.getCoordinates()]);\r\n  }\r\n\r\n  /**\r\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\r\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  segmentPolygonGeometry_(segments, geometry) {\r\n    const rings = geometry.getCoordinates();\r\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\r\n      const coordinates = rings[j];\r\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\r\n        segments.push(coordinates.slice(i, i + 2));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default Snap;\r\n", "/**\r\n * @module ol/interaction/Translate\r\n */\r\nimport Collection from '../Collection.js';\r\nimport Event from '../events/Event.js';\r\nimport Feature from '../Feature.js';\r\nimport InteractionProperty from './Property.js';\r\nimport PointerInteraction from './Pointer.js';\r\nimport {TRUE} from '../functions.js';\r\nimport {always} from '../events/condition.js';\r\nimport {fromUserCoordinate, getUserProjection} from '../proj.js';\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nconst TranslateEventType = {\r\n  /**\r\n   * Triggered upon feature translation start.\r\n   * @event TranslateEvent#translatestart\r\n   * @api\r\n   */\r\n  TRANSLATESTART: 'translatestart',\r\n  /**\r\n   * Triggered upon feature translation.\r\n   * @event TranslateEvent#translating\r\n   * @api\r\n   */\r\n  TRANSLATING: 'translating',\r\n  /**\r\n   * Triggered upon feature translation end.\r\n   * @event TranslateEvent#translateend\r\n   * @api\r\n   */\r\n  TRANSLATEEND: 'translateend',\r\n};\r\n\r\n/**\r\n * A function that takes an {@link module:ol/Feature~Feature} or\r\n * {@link module:ol/render/Feature~RenderFeature} and an\r\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\r\n * translated or `false` otherwise.\r\n * @typedef {function(Feature, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\r\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event should be handled.\r\n * Default is {@link module:ol/events/condition.always}.\r\n * @property {Collection<Feature>} [features] Features contained in this collection will be able to be translated together.\r\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers] A list of layers from which features should be\r\n * translated. Alternatively, a filter function can be provided. The\r\n * function will be called for each layer in the map and should return\r\n * `true` for layers that you want to be translatable. If the option is\r\n * absent, all visible layers will be considered translatable.\r\n * Not used if `features` is provided.\r\n * @property {FilterFunction} [filter] A function\r\n * that takes an {@link module:ol/Feature~Feature} and an\r\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\r\n * translated or `false` otherwise. Not used if `features` is provided.\r\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position\r\n * will be checked for features.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/interaction/Translate~Translate} instances\r\n * are instances of this type.\r\n */\r\nexport class TranslateEvent extends Event {\r\n  /**\r\n   * @param {TranslateEventType} type Type.\r\n   * @param {Collection<Feature>} features The features translated.\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate The event coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} startCoordinate The original coordinates before.translation started\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n   */\r\n  constructor(type, features, coordinate, startCoordinate, mapBrowserEvent) {\r\n    super(type);\r\n\r\n    /**\r\n     * The features being translated.\r\n     * @type {Collection<Feature>}\r\n     * @api\r\n     */\r\n    this.features = features;\r\n\r\n    /**\r\n     * The coordinate of the drag event.\r\n     * @const\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @api\r\n     */\r\n    this.coordinate = coordinate;\r\n\r\n    /**\r\n     * The coordinate of the start position before translation started.\r\n     * @const\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @api\r\n     */\r\n    this.startCoordinate = startCoordinate;\r\n\r\n    /**\r\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\r\n     * @type {import(\"../MapBrowserEvent.js\").default}\r\n     * @api\r\n     */\r\n    this.mapBrowserEvent = mapBrowserEvent;\r\n  }\r\n}\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\r\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<'translateend'|'translatestart'|'translating', TranslateEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\r\n *     'change:active'|'translateend'|'translatestart'|'translating', Return>} TranslateOnSignature\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Interaction for translating (moving) features.\r\n * If you want to translate multiple features in a single action (for example,\r\n * the collection used by a select interaction), construct the interaction with\r\n * the `features` option.\r\n *\r\n * @fires TranslateEvent\r\n * @api\r\n */\r\nclass Translate extends PointerInteraction {\r\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? options : {};\r\n\r\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\r\n\r\n    /***\r\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {TranslateOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * The last position we translated to.\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @private\r\n     */\r\n    this.lastCoordinate_ = null;\r\n\r\n    /**\r\n     * The start position before translation started.\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @private\r\n     */\r\n    this.startCoordinate_ = null;\r\n\r\n    /**\r\n     * @type {Collection<Feature>|null}\r\n     * @private\r\n     */\r\n    this.features_ = options.features !== undefined ? options.features : null;\r\n\r\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\r\n    let layerFilter;\r\n    if (options.layers && !this.features_) {\r\n      if (typeof options.layers === 'function') {\r\n        layerFilter = options.layers;\r\n      } else {\r\n        const layers = options.layers;\r\n        layerFilter = function (layer) {\r\n          return layers.includes(layer);\r\n        };\r\n      }\r\n    } else {\r\n      layerFilter = TRUE;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\r\n     */\r\n    this.layerFilter_ = layerFilter;\r\n\r\n    /**\r\n     * @private\r\n     * @type {FilterFunction}\r\n     */\r\n    this.filter_ = options.filter && !this.features_ ? options.filter : TRUE;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\r\n    this.condition_ = options.condition ? options.condition : always;\r\n\r\n    /**\r\n     * @type {Feature}\r\n     * @private\r\n     */\r\n    this.lastFeature_ = null;\r\n\r\n    this.addChangeListener(\r\n      InteractionProperty.ACTIVE,\r\n      this.handleActiveChanged_\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleDownEvent(event) {\r\n    if (!event.originalEvent || !this.condition_(event)) {\r\n      return false;\r\n    }\r\n    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);\r\n    if (!this.lastCoordinate_ && this.lastFeature_) {\r\n      this.startCoordinate_ = event.coordinate;\r\n      this.lastCoordinate_ = event.coordinate;\r\n      this.handleMoveEvent(event);\r\n\r\n      const features = this.features_ || new Collection([this.lastFeature_]);\r\n\r\n      this.dispatchEvent(\r\n        new TranslateEvent(\r\n          TranslateEventType.TRANSLATESTART,\r\n          features,\r\n          event.coordinate,\r\n          this.startCoordinate_,\r\n          event\r\n        )\r\n      );\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleUpEvent(event) {\r\n    if (this.lastCoordinate_) {\r\n      this.lastCoordinate_ = null;\r\n      this.handleMoveEvent(event);\r\n\r\n      const features = this.features_ || new Collection([this.lastFeature_]);\r\n\r\n      this.dispatchEvent(\r\n        new TranslateEvent(\r\n          TranslateEventType.TRANSLATEEND,\r\n          features,\r\n          event.coordinate,\r\n          this.startCoordinate_,\r\n          event\r\n        )\r\n      );\r\n      // cleanup\r\n      this.startCoordinate_ = null;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer drag events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   */\r\n  handleDragEvent(event) {\r\n    if (this.lastCoordinate_) {\r\n      const newCoordinate = event.coordinate;\r\n      const projection = event.map.getView().getProjection();\r\n\r\n      const newViewCoordinate = fromUserCoordinate(newCoordinate, projection);\r\n      const lastViewCoordinate = fromUserCoordinate(\r\n        this.lastCoordinate_,\r\n        projection\r\n      );\r\n      const deltaX = newViewCoordinate[0] - lastViewCoordinate[0];\r\n      const deltaY = newViewCoordinate[1] - lastViewCoordinate[1];\r\n\r\n      const features = this.features_ || new Collection([this.lastFeature_]);\r\n      const userProjection = getUserProjection();\r\n\r\n      features.forEach(function (feature) {\r\n        const geom = feature.getGeometry();\r\n        if (userProjection) {\r\n          geom.transform(userProjection, projection);\r\n          geom.translate(deltaX, deltaY);\r\n          geom.transform(projection, userProjection);\r\n        } else {\r\n          geom.translate(deltaX, deltaY);\r\n        }\r\n        feature.setGeometry(geom);\r\n      });\r\n\r\n      this.lastCoordinate_ = newCoordinate;\r\n\r\n      this.dispatchEvent(\r\n        new TranslateEvent(\r\n          TranslateEventType.TRANSLATING,\r\n          features,\r\n          newCoordinate,\r\n          this.startCoordinate_,\r\n          event\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle pointer move events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   */\r\n  handleMoveEvent(event) {\r\n    const elem = event.map.getViewport();\r\n\r\n    // Change the cursor to grab/grabbing if hovering any of the features managed\r\n    // by the interaction\r\n    if (this.featuresAtPixel_(event.pixel, event.map)) {\r\n      elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');\r\n      elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');\r\n    } else {\r\n      elem.classList.remove('ol-grab', 'ol-grabbing');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Tests to see if the given coordinates intersects any of our selected\r\n   * features.\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel coordinate to test for intersection.\r\n   * @param {import(\"../Map.js\").default} map Map to test the intersection on.\r\n   * @return {Feature} Returns the feature found at the specified pixel\r\n   * coordinates.\r\n   * @private\r\n   */\r\n  featuresAtPixel_(pixel, map) {\r\n    return map.forEachFeatureAtPixel(\r\n      pixel,\r\n      (feature, layer) => {\r\n        if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\r\n          return undefined;\r\n        }\r\n        if (this.features_ && !this.features_.getArray().includes(feature)) {\r\n          return undefined;\r\n        }\r\n        return feature;\r\n      },\r\n      {\r\n        layerFilter: this.layerFilter_,\r\n        hitTolerance: this.hitTolerance_,\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns the Hit-detection tolerance.\r\n   * @return {number} Hit tolerance in pixels.\r\n   * @api\r\n   */\r\n  getHitTolerance() {\r\n    return this.hitTolerance_;\r\n  }\r\n\r\n  /**\r\n   * Hit-detection tolerance. Pixels inside the radius around the given position\r\n   * will be checked for features.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @api\r\n   */\r\n  setHitTolerance(hitTolerance) {\r\n    this.hitTolerance_ = hitTolerance;\r\n  }\r\n\r\n  /**\r\n   * Remove the interaction from its current map and attach it to the new map.\r\n   * Subclasses may set up event handlers to get notified about changes to\r\n   * the map here.\r\n   * @param {import(\"../Map.js\").default} map Map.\r\n   */\r\n  setMap(map) {\r\n    const oldMap = this.getMap();\r\n    super.setMap(map);\r\n    this.updateState_(oldMap);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  handleActiveChanged_() {\r\n    this.updateState_(null);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Map.js\").default} oldMap Old map.\r\n   * @private\r\n   */\r\n  updateState_(oldMap) {\r\n    let map = this.getMap();\r\n    const active = this.getActive();\r\n    if (!map || !active) {\r\n      map = map || oldMap;\r\n      if (map) {\r\n        const elem = map.getViewport();\r\n        elem.classList.remove('ol-grab', 'ol-grabbing');\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default Translate;\r\n"],
  "mappings": "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",
  "names": ["distance", "squaredDistance", "Vector_default", "target", "Vector_default", "squaredDistance", "Vector_default", "getDefaultStyleFunction", "geometry", "equals", "coordinate", "buffer", "squaredDistance", "getDefaultStyleFunction", "layer", "tempSegment", "squaredDistance"]
}
